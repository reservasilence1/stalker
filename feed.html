<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="utf-8">
    <!-- Google Tag Manager -->
    <script src="js/core.min.js"></script>
    <script src="js/gtm.min.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Stalkea.ai - Feed</title>
    <link rel="stylesheet" href="css/da856031f36d61b4.css">
    <script src="js/auth-check.js"></script>
    <script src="js/geral.js"></script>
    <script src="js/api.js"></script>
    <script src="js/instagram-api.js"></script>
    <script>
        // Detectar e salvar modo admin
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('admin') === 'stalkear321') {
            sessionStorage.setItem('_adminMode', 'true');
            console.log('üîì Modo Admin detectado e salvo no feed');
        }
    </script>
    
    <script>
        // BACKREDIRECT: Impedir usu√°rio de voltar - redirecionar para CTA
        (function() {
            // Adicionar estado no hist√≥rico para detectar "voltar"
            history.pushState(null, '', location.href);
            
            window.addEventListener('popstate', function(e) {
                // Quando usu√°rio tenta voltar, redirecionar para direct
                window.location.href = 'direct.html';
            });
        })();
    </script>
    <style>
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

        /* Header com comportamento de scroll */
        #main-header {
            transition: transform 0.3s ease-in-out;
        }

        #main-header.hidden {
            transform: translateY(-100%);
        }

        /* Pop-up estilo glassmorphism iOS */
        #blocked-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(220, 38, 38, 0.15);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            backdrop-filter: blur(20px) saturate(180%);
            color: #F9F9F9;
            padding: 24px 20px;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            border: 1px solid rgba(249, 249, 249, 0.18);
            z-index: 1000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            max-width: 300px;
            width: calc(100% - 40px);
            text-align: center;
        }

        #blocked-popup.show {
            display: flex;
            animation: popupFadeIn 0.3s ease-out, subtlePulse 3s ease-in-out infinite 0.5s;
        }

        @keyframes popupFadeIn {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.97);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        @keyframes subtlePulse {
            0%, 100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                opacity: 0.98;
                transform: translate(-50%, -50%) scale(1.005);
            }
        }

        #blocked-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            -webkit-backdrop-filter: blur(4px);
            backdrop-filter: blur(4px);
            z-index: 999;
            display: none;
        }

        #blocked-popup-overlay.show {
            display: block;
        }

        /* Notifica√ß√£o estilo Instagram iOS - Glassmorphism */
        #ios-notification {
            position: fixed;
            top: 70px;
            left: 50%;
            cursor: pointer;
            transform: translateX(-50%);
            background: rgba(28, 28, 30, 0.8);
            -webkit-backdrop-filter: blur(30px) saturate(180%);
            backdrop-filter: blur(30px) saturate(180%);
            border-radius: 14px;
            padding: 10px 14px;
            border: 0.5px solid rgba(249, 249, 249, 0.15);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4), inset 0 0.5px 0 rgba(249, 249, 249, 0.15);
            z-index: 1001;
            display: none;
            align-items: center;
            gap: 13px;
            width: calc(100% - 20px);
            max-width: 380px;
            cursor: pointer;
            transition: opacity 0.4s ease-out, transform 0.4s ease-out;
        }

        #ios-notification.show {
            display: flex;
            animation: notificationSlideIn 0.7s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        #ios-notification.hiding {
            opacity: 0;
            transform: translateX(-50%) translateY(-20px) scale(0.95);
        }

        @keyframes notificationSlideIn {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(-30px) scale(0.92);
            }
            60% {
                opacity: 0.8;
                transform: translateX(-50%) translateY(5px) scale(0.98);
            }
            100% {
                opacity: 1;
                transform: translateX(-50%) translateY(0) scale(1);
            }
        }

        .notification-profile-pic {
            width: 40px;
            height: 40px;
            border-radius: 0;
            overflow: hidden;
            flex-shrink: 0;
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .notification-profile-pic img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .notification-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0;
            min-width: 0;
            position: relative;
            line-height: 1.2;
        }

        .notification-time {
            position: absolute;
            top: 0;
            right: 0;
            font-size: 13px;
            font-weight: 400;
            color: rgba(249, 249, 249, 0.5);
            white-space: nowrap;
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", "Helvetica Neue", Helvetica, Arial, sans-serif;
        }

        .notification-text-line {
            font-size: 15px;
            font-weight: 400;
            color: rgba(249, 249, 249, 0.8);
            margin: 0;
            line-height: 1.2;
            letter-spacing: -0.01em;
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", "Helvetica Neue", Helvetica, Arial, sans-serif;
            word-break: keep-all;
            hyphens: none;
        }

        #notification-message {
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: visible;
            text-overflow: ellipsis;
            padding-top: 2px;
        }

        .notification-text-line strong {
            font-weight: 600;
            color: rgba(249, 249, 249, 0.85);
        }

        /* Ajuste proporcional para Galaxy S8 e telas similares (360px) */
        @media (max-width: 360px) {
            #ios-notification {
                width: calc(100% - 12px);
                max-width: 348px;
                padding: 9px 10px;
                gap: 10px;
            }

            .notification-profile-pic {
                width: 38px;
                height: 38px;
            }

            .notification-text-line {
                font-size: 14px;
                letter-spacing: -0.015em;
                padding-right: 0 !important;
                word-break: keep-all;
                hyphens: none;
            }

            #notification-message {
                display: -webkit-box;
                -webkit-line-clamp: 2;
                -webkit-box-orient: vertical;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .notification-time {
                font-size: 11px;
            }

            .notification-content {
                padding-right: 30px;
                overflow: hidden;
            }
        }

        /* Stories - Tamanho padr√£o */
        .story-button {
            position: relative;
            width: 79px;
            height: 79px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
        }

        .story-username {
            font-size: 12px;
            color: rgb(209, 213, 219);
            max-width: 70px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Ajustes para telas maiores (iPhone 12 Pro e similares) */
        @media (min-width: 390px) {
            .story-button {
                width: 91px;
                height: 91px;
            }

            .story-username {
                font-size: 13px;
                max-width: 75px;
            }
        }

        /* Container de stories - reduzir gap */
        #stories-container {
            gap: 10px !important;
        }

        /* Controles de v√≠deo estilo Instagram */
        .video-mute-btn {
            transition: transform 0.1s ease-out;
            -webkit-tap-highlight-color: transparent;
        }

        .video-mute-btn:active {
            transform: scale(0.88);
        }

        .video-mute-btn:hover {
            background: rgba(70, 70, 70, 0.85) !important;
        }

        img {
            image-rendering: -webkit-optimize-contrast;
            image-rendering: optimizeSpeed;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        video {
            -webkit-tap-highlight-color: transparent;
            outline: none;
            pointer-events: auto;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            image-rendering: optimizeSpeed;
        }
        
        video::-webkit-media-controls {
            display: none !important;
        }
        
        video::-webkit-media-controls-enclosure {
            display: none !important;
        }
        
        video::cue {
            display: none !important;
        }

        video:focus {
            outline: none;
        }

        /* Banner de pr√©via gr√°tis - fixo acima da navega√ß√£o inferior */
        #preview-banner {
            position: fixed;
            bottom: 56px;
            left: 2.5%;
            right: 2.5%;
            background: linear-gradient(135deg, rgba(105, 85, 210, 0.98) 0%, rgba(122, 83, 217, 0.98) 100%);
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            backdrop-filter: blur(24px) saturate(180%);
            border-top: 1px solid rgba(249, 249, 249, 0.25);
            box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(249, 249, 249, 0.2);
            z-index: 999;
            padding: 10px 16px;
            display: flex;
            align-items: flex-start;
            justify-content: flex-start;
            gap: 0;
            animation: slideUpBanner 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            border-radius: 16px 16px 0 0;
        }

        @keyframes slideUpBanner {
            from {
                transform: translateY(100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        #preview-banner.hidden {
            animation: slideDownBanner 0.4s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        }

        @keyframes slideDownBanner {
            from {
                transform: translateY(0);
                opacity: 1;
            }
            to {
                transform: translateY(100%);
                opacity: 0;
            }
        }

        .preview-banner-content {
            display: flex;
            flex-direction: column;
            gap: 0;
            flex: 1;
            min-width: 0;
            width: 100%;
            padding-right: 0;
        }

        .preview-banner-text {
            display: flex;
            flex-direction: column;
            gap: 0;
            width: 100%;
        }

        .preview-banner-title {
            font-size: 14px;
            font-weight: 700;
            color: #F9F9F9;
            margin: 0;
            margin-top: -9px;
            padding-top: 6px;
            line-height: 1.2;
            letter-spacing: -0.01em;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 3px;
        }

        .preview-banner-description {
            font-size: 11px;
            color: rgba(249, 249, 249, 0.9);
            margin: 0;
            padding-top: 4px;
            line-height: 1.4;
            width: 100%;
        }

        .preview-timer-inline {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: transparent;
            padding: 0;
            font-size: 13px;
            font-weight: 700;
            color: #F9F9F9;
        }

        .preview-timer {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(249, 249, 249, 0.25);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            padding: 8px 14px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 700;
            color: #F9F9F9;
            white-space: nowrap;
            min-width: 75px;
            justify-content: center;
            border: 1px solid rgba(249, 249, 249, 0.2);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .preview-timer-icon {
            width: 14px;
            height: 14px;
            animation: pulseTimer 2s ease-in-out infinite;
            flex-shrink: 0;
        }

        .preview-timer-inline .preview-timer-icon {
            width: 12px;
            height: 12px;
        }

        @keyframes pulseTimer {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.6;
            }
        }

        /* Anima√ß√£o de curtida estilo Instagram */
        @keyframes instagramLike {
            0% {
                transform: translateY(0) scale(1) rotate(0deg);
                opacity: 1;
            }
            25% {
                transform: translateY(-60px) scale(2.1) rotate(0deg);
                opacity: 1;
            }
            40% {
                transform: translateY(-84px) scale(2.34) rotate(-8deg);
                opacity: 1;
            }
            50% {
                transform: translateY(-84px) scale(2.34) rotate(8deg);
                opacity: 1;
            }
            65% {
                transform: translateY(-42px) scale(1.8) rotate(0deg);
                opacity: 1;
            }
            85% {
                transform: translateY(-10px) scale(1.1) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(0) scale(1) rotate(0deg);
                opacity: 0;
            }
        }

        .like-animation-heart {
            position: absolute;
            width: 26px;
            height: 26px;
            pointer-events: none;
            z-index: 1001;
            background: radial-gradient(circle, #ff3040 0%, #ff6b35 40%, #ff8c42 80%, #ffa500 100%);
            -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='white' d='M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z'/%3E%3C/svg%3E");
            mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='white' d='M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z'/%3E%3C/svg%3E");
            -webkit-mask-size: contain;
            mask-size: contain;
            -webkit-mask-repeat: no-repeat;
            mask-repeat: no-repeat;
            -webkit-mask-position: center;
            mask-position: center;
            animation: instagramLike 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            left: 0;
            top: 0;
        }

        .like-button {
            position: relative;
        }

        /* Banner "You've seen all new posts" */
        #all-posts-seen-banner {
            display: none;
            padding: 20px 16px;
            background: rgb(11, 16, 20);
            margin-bottom: 16px;
            align-items: center;
            gap: 12px;
        }

        #all-posts-seen-banner.show {
            display: flex;
            animation: fadeInBanner 0.4s ease-out;
        }

        @keyframes fadeInBanner {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .all-posts-seen-icon {
            width: 28.8px;
            height: 28.8px;
            border-radius: 50%;
            background: rgb(11, 16, 20);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            position: relative;
            padding: 2px;
        }

        .all-posts-seen-icon::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 50%;
            padding: 2px;
            background: linear-gradient(135deg, #833AB4 0%, #C13584 20%, #E1306C 40%, #FD1D1D 60%, #F77737 75%, #FCAF45 90%, #FFD600 100%);
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask-composite: exclude;
            z-index: 0;
        }

        .all-posts-seen-icon > svg {
            position: relative;
            z-index: 1;
            width: 16px;
            height: 16px;
        }

        .all-posts-seen-icon > svg path {
            stroke: url(feed.html);
        }

        .all-posts-seen-icon defs {
            position: absolute;
        }

        .all-posts-seen-text {
            font-size: 11.2px;
            color: rgb(168, 168, 168);
            line-height: 1.4;
            flex: 1;
        }

        .saiba-mais-link {
            color: rgb(0, 149, 246);
            text-decoration: none;
            cursor: pointer;
        }

        .saiba-mais-link:hover {
            text-decoration: underline;
        }

        .preview-banner-button {
            position: absolute;
            top: 0;
            right: 0;
            background: white;
            color: #6955d2;
            border: none;
            padding: 5px 11px;
            border-radius: 0 16px 0 8px;
            font-size: 13px;
            font-weight: 700;
            cursor: pointer;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2), 0 1px 3px rgba(0, 0, 0, 0.1);
            letter-spacing: -0.01em;
            z-index: 1;
            animation: buttonPulse 2s ease-in-out infinite;
            height: auto;
            line-height: 1.2;
        }

        @keyframes buttonPulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.9;
                transform: scale(1.02);
            }
        }

        /* Loading skeleton do Instagram */
        .post-loading-skeleton {
            padding: 16px 0;
            background: rgb(11, 16, 20);
            margin-bottom: 12px;
        }
        .skeleton-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 0 16px;
            margin-bottom: 12px;
        }
        .skeleton-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(90deg, rgb(38, 38, 38) 25%, rgb(50, 50, 50) 50%, rgb(38, 38, 38) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }
        .skeleton-username {
            width: 120px;
            height: 12px;
            border-radius: 4px;
            background: linear-gradient(90deg, rgb(38, 38, 38) 25%, rgb(50, 50, 50) 50%, rgb(38, 38, 38) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }
        .skeleton-image {
            width: 100%;
            aspect-ratio: 1 / 1;
            background: linear-gradient(90deg, rgb(38, 38, 38) 25%, rgb(50, 50, 50) 50%, rgb(38, 38, 38) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }
        .skeleton-actions {
            display: flex;
            gap: 16px;
            padding: 12px 16px;
        }
        .skeleton-icon {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            background: linear-gradient(90deg, rgb(38, 38, 38) 25%, rgb(50, 50, 50) 50%, rgb(38, 38, 38) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }
        .skeleton-likes {
            width: 80px;
            height: 12px;
            border-radius: 4px;
            margin: 0 16px 8px;
            background: linear-gradient(90deg, rgb(38, 38, 38) 25%, rgb(50, 50, 50) 50%, rgb(38, 38, 38) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }
        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        @media (max-width: 640px) {
            #preview-banner {
                padding: 10px 16px;
            }

            .preview-banner-content {
                padding-right: 0;
            }

            .preview-banner-title {
                font-size: 13px;
                margin-top: -9px;
                padding-top: 6px;
            }

            .preview-banner-description {
                font-size: 11px;
                padding-top: 4px;
            }

            .preview-banner-button {
                top: 0;
                right: 0;
                width: fit-content;
                padding: 5px 11px;
                font-size: 12px;
                line-height: 1.2;
            }

            .preview-timer {
                padding: 5px 10px;
                font-size: 12px;
                min-width: 60px;
            }
        }

    </style>
</head>
<body style="background: rgb(11, 16, 20); font-family: Inter, system-ui, sans-serif; color: #F9F9F9; margin: 0; padding: 0;">
    <!-- Header -->
    <div id="main-header" style="position: fixed; top: 0; left: 0; right: 0; z-index: 50; padding: 12px 16px; background: rgb(11, 16, 20); display: flex; align-items: center; justify-content: space-between;">
        <div style="display: flex; align-items: center;">
            <img alt="Instagram" src="imagens/logo-insta.png" style="height: 28px; object-fit: contain; margin-top: 4px;">
        </div>
        <div style="display: flex; align-items: center; gap: 16px;">
            <button type="button" class="blocked-action" style="position: relative; background: none; border: none; cursor: pointer;">
                <img alt="Curtidas" src="svg/coracao.svg" style="width: 26px; height: 26px;">
                <span style="position: absolute; top: -4px; right: -4px; width: 8px; height: 8px; background: red; border-radius: 50%;"></span>
            </button>
            <a href="direct.html" style="position: relative; background: none; border: none; cursor: pointer; text-decoration: none; display: inline-block;">
                <img alt="Directs" src="svg/enviar.svg" style="width: 24px; height: 24px;">
                <span id="unread-messages-count" style="position: absolute; top: -4px; right: -4px; min-width: 18px; height: 18px; background: red; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: #F9F9F9; font-size: 10px; font-weight: bold; padding: 0 4px;">2</span>
            </a>
        </div>
    </div>

    <!-- Stories -->
    <div style="padding-top: 60px; padding-bottom: 160px;">
        <div style="padding: 12px 16px; overflow-x: auto;" class="hide-scrollbar">
            <div style="display: flex; gap: 12px;" id="stories-container">
                <!-- Stories ser√£o inseridos aqui via JavaScript -->
            </div>
        </div>

        <!-- Posts -->
        <!-- Banner "You've seen all new posts" -->
        <div id="all-posts-seen-banner">
            <div class="all-posts-seen-icon">
                <svg fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <linearGradient id="gradient-check" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#833AB4;stop-opacity:1" />
                            <stop offset="20%" style="stop-color:#C13584;stop-opacity:1" />
                            <stop offset="40%" style="stop-color:#E1306C;stop-opacity:1" />
                            <stop offset="60%" style="stop-color:#FD1D1D;stop-opacity:1" />
                            <stop offset="75%" style="stop-color:#F77737;stop-opacity:1" />
                            <stop offset="90%" style="stop-color:#FCAF45;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#FFD600;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7" stroke="url(#gradient-check)"></path>
                </svg>
            </div>
            <div class="all-posts-seen-text">
                Voc√™ viu todas as publica√ß√µes dispon√≠veis na pr√©via gr√°tis, seja membro VIP para ver todos os posts. <a href="cta.html" class="saiba-mais-link">Virar VIP</a>
            </div>
        </div>

        <div style="margin-top: 16px;" id="posts-container">
            <!-- Posts ser√£o inseridos aqui via JavaScript -->
        </div>
    </div>

    <!-- Bottom Navigation -->
    <div style="position: fixed; bottom: 0; left: 0; right: 0; z-index: 1001; padding: 16px 24px; background: rgb(11, 16, 20); border-top: 1px solid rgb(38, 38, 38); display: flex; align-items: center; justify-content: space-between;">
        <button type="button"><img alt="Home" src="svg/casa.svg" style="width: 24px; height: 24px; opacity: 1;"></button>
        <button type="button" class="blocked-action"><img alt="Buscar" src="svg/lupa.svg" style="width: 24px; height: 24px;"></button>
        <button type="button" class="blocked-action"><img alt="Adicionar" src="svg/adicionar&#32;conteudo.svg" style="width: 24px; height: 24px;"></button>
        <button type="button" class="blocked-action"><img alt="Reels" src="svg/reels.svg" style="width: 24px; height: 24px;"></button>
        <button style="position: relative;" class="blocked-action">
            <div style="width: 24px; height: 24px; border-radius: 50%; overflow: hidden; background: rgb(31, 41, 55); border: 2px solid #F9F9F9;">
                <img alt="Profile" id="nav-profile-pic" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3C/svg%3E" style="width: 100%; height: 100%; object-fit: cover;">
            </div>
        </button>
    </div>

    <!-- Pop-up vermelho para op√ß√µes bloqueadas -->
    <div id="blocked-popup-overlay"></div>
    <div id="blocked-popup">
        <!-- Conte√∫do ser√° inserido dinamicamente -->
    </div>

    <!-- Notifica√ß√£o estilo Instagram iOS -->
    <div id="ios-notification">
        <div class="notification-profile-pic" id="notification-profile-pic">
            <div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: transparent; color: rgba(249,249,249,0.3); font-size: 20px; font-weight: 600;">?</div>
        </div>
        <div class="notification-content">
            <span class="notification-time">Agora</span>
            <p class="notification-text-line" style="margin: 0; margin-bottom: 2px; font-weight: 600; line-height: 1.2; padding-right: 10px;">
                Instagram
            </p>
            <p class="notification-text-line" id="notification-message" style="margin: 0; line-height: 1.2; padding-right: 10px;">
                Fer****** enviou uma mensagem: "Oi del√≠cia, adivinha o que vc esqueceu aqui? kkkk"
            </p>
        </div>
    </div>

    <!-- Banner de pr√©via gr√°tis -->
    <div id="preview-banner">
        <div class="preview-banner-content">
            <div class="preview-banner-text">
                <p class="preview-banner-title">
                    ‚ö° Pr√©via dispon√≠vel por
                    <span class="preview-timer-inline" id="preview-timer">
                        <span id="timer-text">10:00</span>
                        <svg class="preview-timer-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                    </span>
                </p>
                <p class="preview-banner-description">Voc√™ ganhou 10 minutos para testar gratuitamente nossa ferramenta, mas para liberar todas as funcionalidades e ter acesso permanente √© necess√°rio ser um membro VIP.</p>
            </div>
        </div>
        <button class="preview-banner-button" onclick="goToCTA()">Tornar-se VIP</button>
    </div>

    <!-- Script compartilhado de stories -->
    <script src="js/shared-stories.js"></script>
    <script>
        // BLOQUEAR QUALQUER TENTATIVA DE VOLTAR - MANTER USU√ÅRIO PRESO NA P√ÅGINA
        (function() {
            // Adicionar estado ao history para que sempre volte para a mesma p√°gina
            history.pushState(null, null, location.href);

            // Interceptar popstate (quando usu√°rio clica no bot√£o voltar do navegador)
            window.addEventListener('popstate', function(event) {
                // For√ßar voltar para a mesma p√°gina
                history.pushState(null, null, location.href);
            });

            // Interceptar history.back()
            const originalBack = history.back;
            history.back = function() {
                // N√£o fazer nada - manter na mesma p√°gina
                history.pushState(null, null, location.href);
            };

            // Interceptar history.go() com valores negativos
            const originalGo = history.go;
            history.go = function(delta) {
                if (delta < 0) {
                    // Tentando voltar - n√£o permitir
                    history.pushState(null, null, location.href);
                } else {
                    return originalGo.call(history, delta);
                }
            };
        })();

        // Fun√ß√£o para normalizar regi√£o (converter nome completo para sigla)
        function normalizeRegion(region) {
            if (!region) return '';

            const regionMap = {
                'paran√°': 'PR', 'parana': 'PR',
                's√£o paulo': 'SP', 'sao paulo': 'SP',
                'rio de janeiro': 'RJ',
                'minas gerais': 'MG',
                'rio grande do sul': 'RS',
                'santa catarina': 'SC',
                'bahia': 'BA',
                'goi√°s': 'GO', 'goias': 'GO',
                'pernambuco': 'PE',
                'cear√°': 'CE', 'ceara': 'CE',
                'distrito federal': 'DF',
                'esp√≠rito santo': 'ES', 'espirito santo': 'ES',
                'mato grosso': 'MT',
                'mato grosso do sul': 'MS',
                'par√°': 'PA', 'para': 'PA',
                'amazonas': 'AM'
            };

            const regionLower = region.toLowerCase().trim();

            // Se j√° √© sigla (2 letras), retornar como est√°
            if (region.length === 2 && region.match(/^[A-Z]{2}$/i)) {
                return region.toUpperCase();
            }

            // Tentar encontrar no mapa
            for (const [key, sigla] of Object.entries(regionMap)) {
                if (regionLower.includes(key) || key.includes(regionLower)) {
                    return sigla;
                }
            }

            return region;
        }

        // Fun√ß√£o para obter localiza√ß√£o do usu√°rio via IP
        async function getUserLocation() {
            // SEMPRE buscar localiza√ß√£o nova (n√£o usar cache para garantir dados corretos)
            // Remover cache antigo se existir
            const cachedLocation = localStorage.getItem('userLocation');
            if (cachedLocation) {
                console.log('üóëÔ∏è Removendo cache antigo:', cachedLocation);
                localStorage.removeItem('userLocation');
            }

            // Tentar m√∫ltiplas APIs para garantir que pegamos a localiza√ß√£o
            const apis = [
                {
                    url: 'https://ip-api.com/json/?fields=status,message,city,regionName,region,country,lat,lon',
                    parser: (data) => {
                        if (data.status === 'success' && data.city) {
                            // Converter nome completo do estado para sigla se necess√°rio
                            let region = data.region || data.regionName || '';
                            region = normalizeRegion(region);

                            return {
                                city: data.city,
                                region: region,
                                country: data.country || 'Brasil',
                                lat: data.lat,
                                lon: data.lon
                            };
                        }
                        return null;
                    }
                },
                {
                    url: 'https://ipapi.co/json/',
                    parser: (data) => {
                        if (data.city && !data.error) {
                            let region = data.region || data.region_code || '';
                            region = normalizeRegion(region);

                            return {
                                city: data.city,
                                region: region,
                                country: data.country_name || 'Brasil',
                                lat: data.latitude,
                                lon: data.longitude
                            };
                        }
                        return null;
                    }
                },
                {
                    url: 'https://geolocation-db.com/json/',
                    parser: (data) => {
                        if (data.city) {
                            let region = data.state || '';
                            region = normalizeRegion(region);

                            return {
                                city: data.city,
                                region: region,
                                country: data.country_name || 'Brasil',
                                lat: data.latitude,
                                lon: data.longitude
                            };
                        }
                        return null;
                    }
                },
                {
                    url: 'https://api.ipify.org?format=json',
                    getIp: true,
                    parser: async (ip) => {
                        try {
                            const response = await fetch(`https://ip-api.com/json/${ip}?fields=status,city,regionName,region,country,lat,lon`);
                            const data = await response.json();
                            if (data.status === 'success' && data.city) {
                                let region = data.region || data.regionName || '';
                                region = normalizeRegion(region);

                                return {
                                    city: data.city,
                                    region: region,
                                    country: data.country || 'Brasil',
                                    lat: data.lat,
                                    lon: data.lon
                                };
                            }
                        } catch (e) {
                            console.error('Erro ao obter localiza√ß√£o do IP:', e);
                        }
                        return null;
                    }
                },
                {
                    url: 'https://api.db-ip.com/v2/free/self',
                    parser: (data) => {
                        if (data.city) {
                            let region = data.subdivision || '';
                            region = normalizeRegion(region);

                            return {
                                city: data.city,
                                region: region,
                                country: data.countryName || 'Brasil',
                                lat: data.latitude,
                                lon: data.longitude
                            };
                        }
                        return null;
                    }
                },
                {
                    url: 'https://api.country.is/',
                    parser: async () => {
                        try {
                            const ipResponse = await fetch('https://api.ipify.org?format=json');
                            const ipData = await ipResponse.json();
                            const ip = ipData.ip;

                            const geoResponse = await fetch(`https://ipapi.co/${ip}/json/`);
                            const geoData = await geoResponse.json();

                            if (geoData.city && !geoData.error) {
                                let region = geoData.region || geoData.region_code || '';
                                region = normalizeRegion(region);

                                return {
                                    city: geoData.city,
                                    region: region,
                                    country: geoData.country_name || 'Brasil',
                                    lat: geoData.latitude,
                                    lon: geoData.longitude
                                };
                            }
                        } catch (e) {
                            console.error('Erro na API alternativa:', e);
                        }
                        return null;
                    }
                }
            ];

            for (const api of apis) {
                try {

                    let location = null;

                    if (api.getIp) {
                        // Primeiro obter IP, depois localiza√ß√£o
                        const ipResponse = await fetch(api.url);
                        const ipData = await ipResponse.json();
                        location = await api.parser(ipData.ip);
                    } else if (api.parser.constructor.name === 'AsyncFunction') {
                        // Parser ass√≠ncrono
                        location = await api.parser();
                    } else {
                        // Parser s√≠ncrono normal
                        const response = await fetch(api.url, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                            },
                            mode: 'cors'
                        });

                        if (!response.ok) {
                            console.warn('‚ö†Ô∏è Resposta n√£o OK:', response.status);
                            continue;
                        }

                        const data = await response.json();
                        console.log('üì¶ Dados recebidos:', data);
                        location = api.parser(data);
                    }

                    if (location && location.city) {
                        console.log('‚úÖ Localiza√ß√£o obtida:', location.city, '| Regi√£o:', location.region);
                        console.log('üìã Dados completos:', location);

                        // Salvar no localStorage
                        localStorage.setItem('userLocation', JSON.stringify(location));

                        return location;
                    } else {
                        console.warn('‚ö†Ô∏è Cidade n√£o encontrada nos dados');
                    }
                } catch (error) {
                    console.error('‚ùå Erro ao obter localiza√ß√£o de', api.url, ':', error.message);
                    continue; // Tentar pr√≥xima API
                }
            }

            // Se nenhuma API funcionou, retornar null para n√£o mostrar cidade
            console.error('‚ùå N√£o foi poss√≠vel obter localiza√ß√£o de nenhuma API');
            return null;
        }

        // Fun√ß√£o para obter cidades pr√≥ximas usando coordenadas geogr√°ficas
        async function getNearbyCities(lat, lon, userCity) {
            try {
                // Usar fun√ß√µes do api.js para buscar cidades pr√≥ximas
                console.log('üîç Buscando cidades pr√≥ximas via coordenadas:', lat, lon);

                // Reverse geocoding usando fun√ß√£o do api.js
                const data = await reverseGeocode(lat, lon);

                if (data && data.address) {
                    const currentCity = data.address.city || data.address.town || data.address.village || userCity;

                    // Buscar cidade vizinha usando fun√ß√£o do api.js
                    const nearbyCity = await getNeighborCity(lat, lon);
                    const nearbyData = nearbyCity ? [{ address: { city: nearbyCity } }] : [];

                    if (nearbyCity) {
                        // Retornar array com cidade do usu√°rio e cidade vizinha
                        const cities = [userCity];
                        if (nearbyCity.toLowerCase() !== userCity.toLowerCase()) {
                            cities.push(nearbyCity);
                        }
                        console.log('‚úÖ Cidades pr√≥ximas encontradas:', cities);
                        return cities;
                    }
                }
            } catch (error) {
                console.error('‚ùå Erro ao buscar cidades pr√≥ximas:', error);
            }

            // Fallback: retornar apenas a cidade do usu√°rio
            return [userCity];
        }

        // Fun√ß√£o para gerar lista de cidades (cidade do usu√°rio + cidades pr√≥ximas via API)
        async function generateNearbyCities(userCity, userRegion, lat, lon) {
            if (lat && lon) {
                // Buscar cidades pr√≥ximas usando coordenadas
                const nearbyCities = await getNearbyCities(lat, lon, userCity);
                return nearbyCities;
            }

            // Se n√£o temos coordenadas, retornar apenas a cidade do usu√°rio
            console.log('‚ö†Ô∏è Coordenadas n√£o dispon√≠veis, usando apenas cidade do usu√°rio');
            return [userCity];
        }

        // Fun√ß√µes getProxyUrl e maskUsername agora est√£o em shared-stories.js

        // Fun√ß√£o para mostrar pop-up vermelho de bloqueio
        function showBlockedPopup(functionName) {
            const popup = document.getElementById('blocked-popup');
            const overlay = document.getElementById('blocked-popup-overlay');

            // Mapear nomes de fun√ß√µes para o texto correto
            let actionText = 'a esta a√ß√£o';
            if (functionName) {
                const lowerName = functionName.toLowerCase();
                if (lowerName.includes('story') || lowerName.includes('visualizar story')) {
                    actionText = 'aos stories';
                } else if (lowerName.includes('curtir') || lowerName.includes('like')) {
                    actionText = '√†s curtidas';
                } else if (lowerName.includes('reels')) {
                    actionText = 'aos reels';
                } else if (lowerName.includes('perfil') || lowerName.includes('profile')) {
                    actionText = 'ao perfil';
                } else if (lowerName.includes('notifica√ß√£o') || lowerName.includes('notificacao')) {
                    actionText = '√†s notifica√ß√µes';
                } else if (lowerName.includes('comentar')) {
                    actionText = 'aos coment√°rios';
                } else if (lowerName.includes('repost')) {
                    actionText = 'ao repostar';
                } else if (lowerName.includes('enviar')) {
                    actionText = 'ao enviar';
                } else if (lowerName.includes('salvar')) {
                    actionText = 'ao salvar';
                } else if (lowerName.includes('buscar')) {
                    actionText = '√† busca';
                } else if (lowerName.includes('adicionar')) {
                    actionText = 'ao adicionar conte√∫do';
                } else if (lowerName.includes('home')) {
                    actionText = 'ao home';
                } else if (lowerName.includes('mais op√ß√µes')) {
                    actionText = '√†s op√ß√µes';
                }
            }

            if (popup && overlay) {
                // Criar conte√∫do do pop-up estilo iOS glassmorphism
                popup.innerHTML = `
                    <h3 style="font-size: 16px; font-weight: 600; margin: 0 0 10px 0; letter-spacing: -0.1px; opacity: 0.95;">
                        ‚ö†Ô∏é A√ß√£o bloqueada
                    </h3>
                    <p style="font-size: 13px; opacity: 0.85; margin: 0 0 20px 0; line-height: 1.4; font-weight: 400;">
                        Seja um membro VIP do Stalkea.ai<br>para ter acesso ${actionText}
                    </p>
                    <button onclick="goToCTA()" style="background: rgba(249, 249, 249, 0.3); color: #F9F9F9; padding: 10px 20px; border-radius: 10px; font-weight: 500; font-size: 13px; border: 1px solid rgba(249, 249, 249, 0.3); cursor: pointer; width: 100%; transition: all 0.2s; backdrop-filter: blur(10px);" onmouseover="this.style.background='rgba(249, 249, 249, 0.4)'; this.style.borderColor='rgba(249, 249, 249, 0.4)'" onmouseout="this.style.background='rgba(249, 249, 249, 0.3)'; this.style.borderColor='rgba(249, 249, 249, 0.3)'">
                        Adquirir Acesso VIP
                    </button>
                `;

                popup.classList.add('show');
                overlay.classList.add('show');

                // Fechar ao clicar no overlay
                overlay.onclick = function() {
                    popup.classList.remove('show');
                    overlay.classList.remove('show');
                };

                // Fechar ap√≥s 5 segundos
                setTimeout(() => {
                    popup.classList.remove('show');
                    overlay.classList.remove('show');
                }, 5000);
            }
        }

        // Adicionar event listeners para op√ß√µes bloqueadas ap√≥s o conte√∫do ser carregado
        // Vari√°veis para armazenar os handlers e evitar duplica√ß√£o
        let blockedActionsHandler = null;
        let storiesHandler = null;
        let likeHandler = null;
        let saveHandler = null;

        function setupBlockedActions() {
            // Se modo admin estiver ativo, N√ÉO bloquear nada (pesquisas ilimitadas)
            const isAdminMode = sessionStorage.getItem('_adminMode') === 'true';
            if (isAdminMode) {
                console.log('üîì Modo Admin: Bloqueios desabilitados - pesquisas ilimitadas');
                return; // Sair da fun√ß√£o sem adicionar bloqueios
            }
            
            // Remover listeners anteriores se existirem
            if (blockedActionsHandler) {
                document.removeEventListener('click', blockedActionsHandler, true);
            }
            if (storiesHandler) {
                document.removeEventListener('click', storiesHandler, true);
            }
            if (likeHandler) {
                document.removeEventListener('click', likeHandler, true);
            }
            if (saveHandler) {
                document.removeEventListener('click', saveHandler, true);
            }

            // Usar event delegation para capturar cliques em todos os bot√µes bloqueados
            blockedActionsHandler = function(e) {
                const button = e.target.closest('.blocked-action');
                if (button) {
                    e.preventDefault();
                    e.stopPropagation();

                    // Identificar qual fun√ß√£o foi clicada
                    let functionName = 'Esta funcionalidade';
                    const img = button.querySelector('img');
                    if (img) {
                        const alt = img.getAttribute('alt') || '';
                        if (alt.includes('Curtidas') || alt.includes('Curtir')) functionName = 'Curtir';
                        else if (alt.includes('Comentar')) functionName = 'Comentar';
                        else if (alt.includes('Repost')) functionName = 'Repostar';
                        else if (alt.includes('Enviar')) functionName = 'Enviar';
                        else if (alt.includes('Salvar')) functionName = 'Salvar';
                        else if (alt.includes('Buscar')) functionName = 'Buscar';
                        else if (alt.includes('Adicionar')) functionName = 'Adicionar conte√∫do';
                        else if (alt.includes('Reels')) functionName = 'Reels';
                        else if (alt.includes('Home')) functionName = 'Home';
                        else if (alt.includes('Profile') || alt.includes('Perfil')) functionName = 'Perfil';
                    }

                    // Verificar se √© o bot√£o de mais op√ß√µes (3 pontos)
                    if (button.querySelector('svg circle')) {
                        functionName = 'Mais op√ß√µes';
                    }

                    showBlockedPopup(functionName);
                }
            };
            document.addEventListener('click', blockedActionsHandler, true);

            // Bloquear cliques no bot√£o "+" de adicionar story
            const addStoryButton = document.querySelector('.add-story-button');
            if (addStoryButton) {
                addStoryButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    showBlockedPopup('Adicionar story');
                });
            }

            // Bloquear cliques nos stories
            storiesHandler = function(e) {
                // Verificar se o clique foi no bot√£o "+" de adicionar story
                const addStoryBtn = e.target.closest('.add-story-button');
                if (addStoryBtn) {
                    e.preventDefault();
                    e.stopPropagation();
                    showBlockedPopup('Adicionar story');
                    return false;
                }

                // Verificar se o clique foi em um story (dentro do container de stories)
                const storiesContainer = document.getElementById('stories-container');
                if (storiesContainer && storiesContainer.contains(e.target)) {
                    // Verificar se √© um bot√£o de story ou imagem de story
                    const storyButton = e.target.closest('button');
                    const storyDiv = e.target.closest('div[style*="display: flex"][style*="flex-direction: column"]');

                    if (storyButton || storyDiv) {
                        // Verificar se n√£o √© o story do pr√≥prio usu√°rio
                        const storyText = storyDiv?.querySelector('span')?.textContent;
                        if (storyText && storyText !== 'Seu story') {
                            e.preventDefault();
                            e.stopPropagation();
                            showBlockedPopup('Visualizar story');
                            return false;
                        }
                    }
                }
            };
            document.addEventListener('click', storiesHandler, true);

            // Funcionalidade de curtir
            likeHandler = function(e) {
                const likeButton = e.target.closest('.like-button');
                if (likeButton) {
                    e.preventDefault();
                    e.stopPropagation();
                    const postIndex = parseInt(likeButton.getAttribute('data-post-index'));
                    const isLiked = likeButton.getAttribute('data-liked') === 'true';

                    // Alternar estado
                    const newLikedState = !isLiked;
                    likeButton.setAttribute('data-liked', newLikedState);

                    // Mostrar anima√ß√£o de curtida estilo Instagram (apenas quando curte, n√£o quando descurte)
                    if (newLikedState) {
                        // Encontrar a imagem do cora√ß√£o para posicionar a anima√ß√£o
                    const img = likeButton.querySelector('img');
                    if (img) {
                            // Obter posi√ß√£o do √≠cone relativa ao bot√£o
                            const imgRect = img.getBoundingClientRect();
                            const buttonRect = likeButton.getBoundingClientRect();

                            // Calcular posi√ß√£o relativa do centro do √≠cone
                            const imgCenterX = imgRect.left - buttonRect.left + imgRect.width / 2;
                            const imgCenterY = imgRect.top - buttonRect.top + imgRect.height / 2;

                            // Criar elemento de anima√ß√£o
                            const heartAnim = document.createElement('div');
                            heartAnim.className = 'like-animation-heart';

                            // Posicionar exatamente no centro do √≠cone
                            heartAnim.style.left = (imgCenterX - 13) + 'px'; // 13px = metade de 26px (tamanho do cora√ß√£o animado)
                            heartAnim.style.top = (imgCenterY - 13) + 'px';

                            // Adicionar ao bot√£o de curtir (relativo ao bot√£o)
                            likeButton.appendChild(heartAnim);

                            // Esconder o √≠cone branco temporariamente para ver a anima√ß√£o
                            img.style.opacity = '0';

                            // Atualizar √≠cone ap√≥s a anima√ß√£o subir (quando retorna)
                            setTimeout(() => {
                                if (img) {
                                    img.src = '../svg/coracao-curtido.svg';
                                    img.style.opacity = '1';
                                }
                            }, 280);

                            // Remover ap√≥s anima√ß√£o
                            setTimeout(() => {
                                if (heartAnim.parentNode) {
                                    heartAnim.parentNode.removeChild(heartAnim);
                                }
                            }, 400);
                        }
                    } else {
                        // Se descurtiu, apenas atualizar o √≠cone
                        const img = likeButton.querySelector('img');
                        if (img) {
                            img.src = '../svg/coracao.svg';
                        }
                    }

                    // Atualizar contador de curtidas (ao lado do cora√ß√£o)
                    const likesCountDisplay = likeButton.querySelector('.likes-count-display');
                    if (likesCountDisplay) {
                        let currentLikes = parseInt(likesCountDisplay.textContent) || 0;
                        currentLikes = newLikedState ? currentLikes + 1 : currentLikes - 1;
                        likesCountDisplay.textContent = currentLikes;
                    }
                }
            };
            document.addEventListener('click', likeHandler, true);

            // Funcionalidade de salvar
            saveHandler = function(e) {
                const saveButton = e.target.closest('.save-button');
                if (saveButton) {
                    e.preventDefault();
                    e.stopPropagation();
                    const isSaved = saveButton.getAttribute('data-saved') === 'true';

                    // Alternar estado
                    const newSavedState = !isSaved;
                    saveButton.setAttribute('data-saved', newSavedState);

                    // Atualizar √≠cone
                    const img = saveButton.querySelector('img');
                    if (img) {
                        img.src = newSavedState ? '../svg/salvar-salvado.svg' : '../svg/salvar.svg';
                    }
                }
            };
            document.addEventListener('click', saveHandler, true);
        }

        // Fun√ß√£o para obter URL da API (tenta diferentes portas)
        // Fun√ß√£o getApiUrl est√° em geral.js

        // Fun√ß√£o para gerar usu√°rios aleat√≥rios (apenas visual)
        // Verificar se geral.js foi carregado
        if (typeof clearAllData === 'undefined') {
            console.error('‚ùå geral.js n√£o foi carregado! Verifique se o script est√° inclu√≠do no <head>');
        }

        // Fun√ß√µes de localiza√ß√£o agora est√£o em api.js
        // Usar cache local para evitar m√∫ltiplas chamadas na mesma p√°gina
        let cachedCityData = null;

        async function detectCityByIPWithCache() {
            if (cachedCityData) return cachedCityData;
            cachedCityData = await detectCityByIP();
            return cachedCityData;
        }

        async function loadFeedData() {
                // console.log('üöÄ [LOADFEEDDATA] Iniciando loadFeedData...');

            // Ler username da URL ou localStorage
            const urlParams = new URLSearchParams(window.location.search);
            let username = urlParams.get('username') || localStorage.getItem('username') || 'usuario';
            
            // Salvar username no localStorage se vier da URL (para garantir que esteja dispon√≠vel)
            if (urlParams.get('username')) {
                localStorage.setItem('username', urlParams.get('username'));
                username = urlParams.get('username');
            }
                // console.log('üîç [LOADFEEDDATA] Username:', username);

                // console.log('üìã [LOADFEEDDATA] Feed carregando dados aleat√≥rios para:', username);

            // Verificar se o perfil √© privado
            const cleanUsername = username.replace(/^@+/, '').trim();
            const storageKey = 'instagram_profile';

            // Buscar foto de perfil real do localStorage
            let profilePicUrl = './imagens/perfil-espionado.jpeg';
            let fullName = typeof generateRandomName === 'function' ? generateRandomName() : 'Usu√°rio';
            let isPrivate = false;
            
            try {
                const savedData = localStorage.getItem(storageKey);
                if (savedData) {
                    const parsedData = JSON.parse(savedData);
                    if (parsedData.profile_pic_url) {
                        profilePicUrl = parsedData.profile_pic_url;
                    }
                    if (parsedData.full_name) {
                        fullName = parsedData.full_name;
                    }
                    isPrivate = parsedData.is_private || false;
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Erro ao buscar foto de perfil:', error);
            }
            
            const postCount = Math.floor(Math.random() * 500);
            const bio = '';

            // Buscar seguidores/chaining do localStorage
            const storiesDataKey = 'feed_stories_data';
            const storiesOrderKey = 'feed_stories_order';
            let allUsers = [];

            // Tentar buscar dados reais primeiro
            if (isPrivate) {
                // Perfil privado: usar chaining_results
                const chainingKey = 'chaining_results';
                const chainingData = localStorage.getItem(chainingKey);
                
                if (chainingData) {
                    try {
                        const chainingResults = JSON.parse(chainingData);
                        allUsers = chainingResults.map(user => {
                            // Aplicar proxy √† URL da imagem de perfil
                            let profilePicUrl = user.profile_pic_url || './imagens/perfil-sem-foto.jpeg';
                            if (typeof getProxyImageUrl === 'function' && profilePicUrl && !profilePicUrl.startsWith('../')) {
                                profilePicUrl = getProxyImageUrl(profilePicUrl);
                            }
                            return {
                                username: user.username || '',
                                full_name: user.full_name || '',
                                profile_pic_url: profilePicUrl
                            };
                        }).filter(u => u.username);
                        console.log('‚úÖ [STORIES] Usando chaining_results do localStorage:', allUsers.length, 'usu√°rios');
                    } catch (e) {
                        console.warn('‚ö†Ô∏è Erro ao parsear chaining_results:', e);
                    }
                }
            } else {
                // Perfil p√∫blico: usar followers
                const possibleFollowersKeys = [
                    'instagram_followers',
                    'followers'
                ];

                console.log('üîç [STORIES P√öBLICO] Tentando buscar followers nas chaves:', possibleFollowersKeys);
                
                let followersData = null;
                let usedFollowersKey = null;
                
                for (const key of possibleFollowersKeys) {
                    const data = localStorage.getItem(key);
                    if (data) {
                        try {
                            const parsed = JSON.parse(data);
                            if (parsed && Array.isArray(parsed) && parsed.length > 0) {
                                followersData = data;
                                usedFollowersKey = key;
                                console.log('‚úÖ [STORIES P√öBLICO] followers encontrado na chave:', key, '-', parsed.length, 'seguidores');
                                break;
                            }
                        } catch (e) {
                            console.warn(`‚ö†Ô∏è [STORIES P√öBLICO] Erro ao parsear chave ${key}:`, e);
                            continue;
                        }
                    }
                }
                
                if (followersData) {
                    try {
                        const followers = JSON.parse(followersData);
                        allUsers = followers.map(user => {
                            // Aplicar proxy √† URL da imagem de perfil
                            let profilePicUrl = user.profile_pic_url || user.profile_pic_url_hd || './imagens/perfil-sem-foto.jpeg';
                            if (typeof getProxyImageUrl === 'function' && profilePicUrl && !profilePicUrl.startsWith('../')) {
                                profilePicUrl = getProxyImageUrl(profilePicUrl);
                            }
                            return {
                                username: user.username || '',
                                full_name: user.full_name || '',
                                profile_pic_url: profilePicUrl
                            };
                        }).filter(u => u.username);
                        console.log('‚úÖ [STORIES P√öBLICO] Usando followers do localStorage:', allUsers.length, 'usu√°rios');
                    } catch (e) {
                        console.warn('‚ö†Ô∏è [STORIES P√öBLICO] Erro ao parsear followers:', e);
                    }
                } else {
                    console.warn('‚ö†Ô∏è [STORIES P√öBLICO] followers n√£o encontrado. Chaves tentadas:', possibleFollowersKeys);
                }
            }

            // Se n√£o encontrou dados reais, verificar cache de stories ou gerar novos
            if (allUsers.length === 0) {
                const cachedStories = localStorage.getItem(storiesDataKey);
                if (cachedStories) {
                    allUsers = JSON.parse(cachedStories);
                }
            }

            // Se ainda n√£o h√° stories, gerar novos
            if (allUsers.length === 0 && typeof generateRandomUsers === 'function') {
                const randomUsers = generateRandomUsers(15);
                allUsers = randomUsers.map(user => ({
                    username: user.username || '',
                    full_name: user.full_name || '',
                    profile_pic_url: './imagens/perfil-sem-foto.jpeg'
                })).filter(u => u.username);
                localStorage.setItem(storiesDataKey, JSON.stringify(allUsers));
            }

            // Sempre renderizar (sem cache)
                // console.log('üîÑ [LOADFEEDDATA] Verificando cache...');
            const hasValidCache = false;
                // console.log('‚úÖ [LOADFEEDDATA] Cache desabilitado, sempre renderizar');

            if (false) { // Nunca usar cache
                console.log('‚ö†Ô∏è [LOADFEEDDATA] Entrando no bloco de cache (nunca deve acontecer)');
                console.log('‚úÖ Feed j√° renderizado, usando HTML salvo do cache');

                // Restaurar HTML dos stories
                const storiesContainer = document.getElementById('stories-container');
                let storiesRestored = false;
                if (storiesContainer) {
                    const savedStories = sessionStorage.getItem('feed_stories_html');
                    if (savedStories && savedStories.trim().length > 0) {
                        storiesContainer.innerHTML = savedStories;
                        storiesRestored = true;
                    }
                }

                // Restaurar HTML dos posts
                const postsContainer = document.getElementById('posts-container');
                let postsRestored = false;
                if (postsContainer) {
                    const savedPosts = sessionStorage.getItem(`feed_posts_html_${username}`);
                    if (savedPosts && savedPosts.trim().length > 0) {
                        postsContainer.innerHTML = savedPosts;
                        postsRestored = true;
                    }
                }

                // Se ambos stories e posts foram restaurados com sucesso, retornar
                if (storiesRestored && postsRestored) {
                    // Atualizar foto de perfil na navega√ß√£o inferior
                    const navProfilePic = document.getElementById('nav-profile-pic');
                    if (navProfilePic && profilePicUrl) {
                        navProfilePic.src = profilePicUrl;
                        navProfilePic.style.opacity = '0.8';
                    }

                    // Se username mudou, esconder banner antes de verificar
                    // (vari√°veis n√£o definidas porque cache est√° desabilitado)

                    // ===== VERIFICAR SE BANNER J√Å FOI MOSTRADO (F5) =====
                    const bannerKey = 'all_posts_seen_banner_shown';
                    const bannerWasShown = false; // Sempre false porque cache est√° desabilitado

                    if (bannerWasShown) {
                        // Usu√°rio j√° viu todos os posts antes - mostrar todos e o banner
                        const allPostsCached = postsContainer.querySelectorAll('.post-container');
                        allPostsCached.forEach(post => post.style.display = 'block');

                        const banner = document.getElementById('all-posts-seen-banner');
                        if (banner) banner.classList.add('show');
                    } else {
                        // Ainda n√£o viu todos - aplicar infinite scroll
                        const allPostsCached = postsContainer.querySelectorAll('.post-container');
                        let visiblePostsCached = 3;
                        let allLoadedCached = false;

                        // Esconder posts al√©m dos 3 primeiros
                        allPostsCached.forEach((post, index) => {
                            post.style.display = index < visiblePostsCached ? 'block' : 'none';
                        });

                        // Fun√ß√£o para criar skeleton
                        function createSkeletonCached() {
                            const skeleton = document.createElement('div');
                            skeleton.className = 'post-loading-skeleton';
                            skeleton.innerHTML = `
                                <div class="skeleton-header"><div class="skeleton-avatar"></div><div class="skeleton-username"></div></div>
                                <div class="skeleton-image"></div>
                                <div class="skeleton-actions"><div class="skeleton-icon"></div><div class="skeleton-icon"></div><div class="skeleton-icon"></div></div>
                                <div class="skeleton-likes"></div>
                            `;
                            return skeleton;
                        }

                        // Fun√ß√£o para carregar mais
                        function loadMoreCached() {
                            if (visiblePostsCached >= allPostsCached.length) {
                                allLoadedCached = true;
                                const banner = document.getElementById('all-posts-seen-banner');
                                if (banner) {
                                    banner.classList.add('show');
                                    // Scroll suave para o topo
                                    setTimeout(() => {
                                        window.scrollTo({ top: 0, behavior: 'smooth' });
                                    }, 500);
                                }
                                return;
                            }

                            const skeleton = createSkeletonCached();
                            postsContainer.appendChild(skeleton);

                            setTimeout(() => {
                                skeleton.remove();
                                const prev = visiblePostsCached;
                                visiblePostsCached = Math.min(visiblePostsCached + 3, allPostsCached.length);
                                for (let i = prev; i < visiblePostsCached; i++) {
                                    if (allPostsCached[i]) allPostsCached[i].style.display = 'block';
                                }
                                if (visiblePostsCached >= allPostsCached.length) {
                                    allLoadedCached = true;
                                    const banner = document.getElementById('all-posts-seen-banner');
                                    if (banner) {
                                        banner.classList.add('show');
                                        // Scroll suave para o topo
                                        setTimeout(() => {
                                            window.scrollTo({ top: 0, behavior: 'smooth' });
                                        }, 500);
                                    }
                                }
                            }, 800);
                        }

                        let loadingCached = false;
                        window.addEventListener('scroll', function() {
                            if (loadingCached || allLoadedCached) return;
                            if (window.scrollY + window.innerHeight >= document.documentElement.scrollHeight - 300) {
                                loadingCached = true;
                                loadMoreCached();
                                setTimeout(() => { loadingCached = false; }, 1000);
                            }
                        }, { passive: true });
                    }

                    // Configurar event listeners
                    setTimeout(setupBlockedActions, 100);

                    // Banner j√° foi escondido no in√≠cio de loadFeedData, n√£o precisa chamar checkBannerOnLoad aqui

                    // Se tem cache v√°lido e ambos foram restaurados, n√£o fazer chamadas de API - retornar aqui
                    return;
                } else {
                    // Se algum dos caches estiver vazio, continuar com renderiza√ß√£o normal
                    console.log('‚ö†Ô∏è Cache encontrado mas stories ou posts est√£o vazios, renderizando novamente...');
                }
            }

                // console.log('üîÑ Primeira renderiza√ß√£o do feed, salvando HTML no cache');

            // Renderizar stories
            const storiesContainer = document.getElementById('stories-container');
                // console.log('üîç [STORIES] storiesContainer encontrado:', !!storiesContainer);
                // console.log('üîç [STORIES] username:', username);
                // console.log('üîç [STORIES] profilePicUrl:', profilePicUrl);
            if (storiesContainer && username && profilePicUrl) {
                // Limpar container primeiro
                storiesContainer.innerHTML = '';

                // Story do usu√°rio principal
                // console.log('‚úÖ [STORIES] Criando primeiro story do usu√°rio...');
                const firstStoryHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 4px;">
                        <button class="story-button">
                            <div style="width: 100%; height: 100%; border-radius: 50%; background: rgb(31, 41, 55); position: relative; overflow: visible;">
                                <div style="width: 100%; height: 100%; border-radius: 50%; overflow: hidden;">
                                    <img alt="${username}" src="https://meustalker.vercel.app/${profilePicUrl}" loading="eager" decoding="async" style="width: 100%; height: 100%; object-fit: cover; opacity: 0.8;" onerror="this.src='./imagens/perfil-espionado.jpeg';">
                                </div>
                                <div class="add-story-button" style="position: absolute; bottom: -2px; right: -2px; width: 26px; height: 26px; background-color: #F9F9F9; border-radius: 50%; display: flex; align-items: center; justify-content: center; border: 2.6px solid rgb(31, 41, 55); z-index: 30; cursor: pointer;">
                                    <svg width="15" height="14.5" viewBox="0 0 24 24" fill="none" stroke="rgb(31, 41, 55)" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                                        <line x1="12" y1="5" x2="12" y2="19"></line>
                                        <line x1="5" y1="12" x2="19" y2="12"></line>
                                    </svg>
                                </div>
                            </div>
                        </button>
                        <span class="story-username">Seu story</span>
                    </div>
                `;
                storiesContainer.innerHTML = firstStoryHTML;
                console.log('‚úÖ [STORIES] Primeiro story criado');

                // Adicionar event listener para o bot√£o "+" de adicionar story
                setTimeout(() => {
                    const addStoryButton = document.querySelector('.add-story-button');
                    if (addStoryButton) {
                        addStoryButton.addEventListener('click', function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            showBlockedPopup('Adicionar story');
                        });
                    }
                }, 100);

                // Criar stories aleat√≥rios
                // LIMITAR a 15 stories normais (1 do usu√°rio + 14 outros)
                const MAX_STORIES = 15;

                // Verificar se allUsers est√° vazio e gerar dados aleat√≥rios
                // console.log('üîç [STORIES] Verificando allUsers.length:', allUsers.length);
                if (allUsers.length === 0) {
                    console.log('‚ö†Ô∏è [STORIES] allUsers est√° vazio, gerando dados aleat√≥rios...');
                    if (typeof generateRandomUsers === 'function') {
                        console.log('‚úÖ [STORIES] generateRandomUsers dispon√≠vel, gerando 15 usu√°rios...');
                        const randomUsers = generateRandomUsers(15);
                        console.log('üì¶ [STORIES] randomUsers gerados:', randomUsers.length);
                        allUsers = randomUsers.map(user => ({
                            username: user.username || '',
                                            full_name: user.full_name || '',
                            profile_pic_url: './imagens/perfil-sem-foto.jpeg'
                        })).filter(u => u.username);
                        console.log(`‚úÖ [STORIES] ${allUsers.length} stories gerados aleatoriamente`);
                        console.log('üìã [STORIES] Primeiros 3 usu√°rios:', allUsers.slice(0, 3));
                    } else {
                        console.error('‚ùå [STORIES] generateRandomUsers n√£o dispon√≠vel!');
                    }
                        } else {
                    // console.log('‚úÖ [STORIES] allUsers j√° tem dados:', allUsers.length, 'usu√°rios');
                }

                const validStories = allUsers.filter(user => user && user.username && user.profile_pic_url).slice(0, MAX_STORIES - 1);
                // console.log('‚úÖ [STORIES] validStories:', validStories.length);

                // Verificar se j√° existe ordem salva no localStorage
                let orderedStories = [...validStories];
                const savedOrder = localStorage.getItem(storiesOrderKey);
                
                if (savedOrder) {
                    // Usar ordem salva
                    try {
                        const orderArray = JSON.parse(savedOrder);
                        // Mapear usernames para objetos
                        const usernameMap = {};
                        validStories.forEach(s => usernameMap[s.username] = s);
                        // Reconstruir na ordem salva
                        const reordered = orderArray.map(username => usernameMap[username]).filter(Boolean);
                        // S√≥ usar se todos os stories foram encontrados
                        if (reordered.length === validStories.length) {
                            orderedStories = reordered;
                            console.log('‚úÖ [STORIES] Usando ordem salva do localStorage');
                        } else {
                            // Ordem inv√°lida, embaralhar novamente
                            console.log('‚ö†Ô∏è [STORIES] Ordem salva inv√°lida, reembaralhando...');
                            for (let i = orderedStories.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [orderedStories[i], orderedStories[j]] = [orderedStories[j], orderedStories[i]];
                            }
                            localStorage.setItem(storiesOrderKey, JSON.stringify(orderedStories.map(s => s.username)));
                        }
                    } catch (e) {
                        console.error('‚ùå [STORIES] Erro ao parsear ordem:', e);
                    }
                } else {
                    // Primeira vez: embaralhar e salvar ordem
                    // console.log('üîÑ [STORIES] Primeira vez, embaralhando stories...');
                    for (let i = orderedStories.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [orderedStories[i], orderedStories[j]] = [orderedStories[j], orderedStories[i]];
                    }
                    // Salvar ordem no localStorage
                    localStorage.setItem(storiesOrderKey, JSON.stringify(orderedStories.map(s => s.username)));
                    // console.log('üíæ [STORIES] Ordem salva no localStorage');
                }

                // Renderizar todos os stories normais (sem blur) - usar lazy loading
                const storiesHTML = orderedStories.map((user, index) => {
                    // Usar full_name se dispon√≠vel, sen√£o usar username
                    const displayName = user.full_name || user.username || 'Usuario';
                    const maskedUsername = maskUsername(displayName);
                    // Usar foto de perfil real se dispon√≠vel (com proxy leve para stories)
                    let profilePic = user.profile_pic_url || './imagens/perfil-sem-foto.jpeg';
                    if (typeof getProxyImageUrlLight === 'function' && profilePic && !profilePic.startsWith('../') && !profilePic.startsWith('./')) {
                        profilePic = getProxyImageUrlLight(profilePic);
                    }
                    // Primeiros 3 stories com borda verde (melhores amigos)
                    const borderColor = index < 3 ? '#44B051' : 'linear-gradient(45deg, #f09433, #e6683c, #dc2743, #cc2366, #bc1888)';
                    return `
                            <div style="display: flex; flex-direction: column; align-items: center; gap: 4px;">
                                <button class="story-button">
                                    <div style="width: 100%; height: 100%; border-radius: 50%; padding: 3px; background: ${borderColor};">
                                        <div style="width: 100%; height: 100%; border-radius: 50%; background: rgb(11, 16, 20); padding: 2px;">
                                            <div style="width: 100%; height: 100%; border-radius: 50%; overflow: hidden; background: rgb(31, 41, 55); position: relative;">
                                                <img alt="${maskedUsername}" src="https://meustalker.vercel.app/${profilePic}" loading="lazy" decoding="async" style="width: 100%; height: 100%; object-fit: cover; opacity: 0.8;">
                                            </div>
                                        </div>
                                    </div>
                                </button>
                                <span class="story-username">${maskedUsername}</span>
                            </div>
                        `;
                }).join('');
                console.log('üìù [STORIES] Adicionando storiesHTML ao container, tamanho:', storiesHTML.length);
                storiesContainer.innerHTML += storiesHTML;
                console.log('‚úÖ [STORIES] Stories HTML adicionado ao container');

                // Duplicar apenas 5 stories com blur e cadeado no final
                const MAX_BLURRED_STORIES = 5;
                const blurredStories = orderedStories.slice(0, MAX_BLURRED_STORIES);
                const usernameLetters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];
                const blurredStoriesHTML = blurredStories.map((user, index) => {
                    // Gerar username com apenas 1 letra vis√≠vel
                    const randomLetter = usernameLetters[index % usernameLetters.length] || usernameLetters[Math.floor(Math.random() * usernameLetters.length)];
                    const maskedUsername = randomLetter + '******';
                    return `
                            <div style="display: flex; flex-direction: column; align-items: center; gap: 4px;">
                                <button class="story-button">
                                    <div style="width: 100%; height: 100%; border-radius: 50%; padding: 3px; background: linear-gradient(45deg, #f09433, #e6683c, #dc2743, #cc2366, #bc1888);">
                                        <div style="width: 100%; height: 100%; border-radius: 50%; background: rgb(11, 16, 20); padding: 2px;">
                                            <div style="width: 100%; height: 100%; border-radius: 50%; overflow: hidden; background: rgb(55, 65, 81); position: relative; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);">
                                                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; z-index: 10;">
                                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                                                        <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                                                    </svg>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </button>
                                <span class="story-username">${maskedUsername}</span>
                            </div>
                        `;
                }).join('');
                storiesContainer.innerHTML += blurredStoriesHTML;

                // N√£o salvar no sessionStorage - renderizar sempre dinamicamente
            }

            // Atualizar foto de perfil na navega√ß√£o inferior
            const navProfilePic = document.getElementById('nav-profile-pic');
            if (navProfilePic && profilePicUrl) {
                navProfilePic.src = profilePicUrl;
                navProfilePic.style.opacity = '0.8';
            }

            // Renderizar m√∫ltiplos posts com rea√ß√µes
            console.log('üé® [LOADFEEDDATA] Procurando posts-container...');
            const postsContainer = document.getElementById('posts-container');
            console.log('üîç [LOADFEEDDATA] postsContainer encontrado:', !!postsContainer);
            if (postsContainer && username) {
                console.log('‚úÖ [POSTS] Renderizando posts...');
                // Dados dos posts aleat√≥rios
                // Fun√ß√µes auxiliares para posts reais
                function formatPostDate(timestamp) {
                    // Se n√£o tiver timestamp v√°lido, retornar null
                    if (!timestamp || timestamp <= 0) return null;
                    
                    const now = new Date();
                    const postDate = new Date(timestamp * 1000);
                    const diffMs = now - postDate;
                    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
                    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
                    const diffYears = Math.floor(diffDays / 365);

                    if (diffYears >= 1) return null; // N√£o mostrar posts > 1 ano (conforme solicitado)
                    
                    // Menos de 24 horas: "h√° XX horas"
                    if (diffHours < 24) {
                        if (diffHours === 0) return 'Agora';
                        return `h√° ${diffHours} hora${diffHours > 1 ? 's' : ''}`;
                    }
                    
                    // Entre 1 e 7 dias: "h√° X dias"
                    if (diffDays >= 1 && diffDays <= 7) {
                        return `h√° ${diffDays} dia${diffDays > 1 ? 's' : ''}`;
                    }
                    
                    // Mais de 7 dias: "X de [m√™s] de XXXX"
                    const meses = ['janeiro', 'fevereiro', 'mar√ßo', 'abril', 'maio', 'junho', 
                                   'julho', 'agosto', 'setembro', 'outubro', 'novembro', 'dezembro'];
                    const dia = postDate.getDate();
                    const mes = meses[postDate.getMonth()];
                    const ano = postDate.getFullYear();
                    
                    return `${dia} de ${mes} de ${ano}`;
                }

                function calculatePostRelevance(post, isMutual = false) {
                    if (!post) return -1000;

                    const likes = post.likes || post.like_count || 0;
                    const timestamp = post.timestamp || post.taken_at || 0;
                    const daysOld = Math.floor((Date.now() - (timestamp * 1000)) / (1000 * 60 * 60 * 24));

                    let score = 0;

                    // Posts com > 300 likes s√£o muito populares (spam)
                    if (likes > 300) score = -500;

                    // Posts pr√≥ximos de 50 curtidas s√£o melhores
                    const distanceFrom50 = Math.abs(likes - 50);
                    score += Math.max(0, 50 - distanceFrom50);

                    // Quanto mais recente, melhor
                    score += Math.max(0, 30 - daysOld);

                    // M√∫tuos ganham b√¥nus
                    if (isMutual) score += 50;

                    return score;
                }

                const defaultPosts = [
                    { likes: 46, comments: 9, reposts: 3, shares: 1, liked: true, saved: false, date: '18 de novembro', caption: 'ü©∑ perfeita como sempre', aspectRatio: '1 / 1', locationType: 'neighbor_city' },
                    { likes: 28, comments: 1, reposts: 1, shares: 0, liked: false, saved: true, date: '19 de novembro', caption: 'Finalmente deu certo', aspectRatio: '3 / 2', locationType: 'neighbor_city' },
                    { likes: 51, comments: 7, reposts: 4, shares: 0, liked: true, saved: false, date: '18 de novembro', caption: 'Algu√©m a√≠?', aspectRatio: '1 / 1', locationType: 'none' },
                    { likes: 34, comments: 1, reposts: 3, shares: 3, liked: false, saved: false, date: '20 de novembro', caption: 'N√£o sei nem por onde come√ßar üíï', aspectRatio: '1 / 1', locationType: 'famous_place' },
                    { likes: 42, comments: 2, reposts: 3, shares: 0, liked: true, saved: true, date: '19 de novembro', caption: 'Mais um dia, mais uma conquista üéâ', aspectRatio: '3 / 2', locationType: 'none' },
                    { likes: 69, comments: 3, reposts: 1, shares: 3, liked: true, saved: false, date: '21 de novembro', caption: 'As melhores coisas da vida s√£o de gra√ßa', aspectRatio: '1 / 1', locationType: 'ip_city' },
                    { likes: 38, comments: 0, reposts: 1, shares: 0, liked: true, saved: false, date: '19 de novembro', caption: 'Tarde perfeita', aspectRatio: '1 / 1', locationType: 'none' },
                    { likes: 72, comments: 2, reposts: 0, shares: 1, liked: false, saved: true, date: '16 de novembro', caption: 'A gente sempre acha que sabe quer üòä', aspectRatio: '3 / 2', locationType: 'none' }
                ];

                // Verificar se j√° existem posts em sessionStorage (n√£o regenerar ao dar F5)
                const sessionPostsKey = `feed_posts_${username}`;
                let postsData = null;

                // Limpar cache para for√ßar regenera√ß√£o com valores corretos
                sessionStorage.removeItem(sessionPostsKey); // DEBUG: For√ßando regenera√ß√£o

                const cachedPosts = sessionStorage.getItem(sessionPostsKey);
                if (cachedPosts) {
                    try {
                        postsData = JSON.parse(cachedPosts);
                    } catch (e) {
                        postsData = null;
                    }
                }

                // Se n√£o h√° posts em cache, gerar novos
                if (!postsData || postsData.length === 0) {
                    // Buscar posts reais do localStorage primeiro
                    let postsReais = [];
                    
                    try {
                        if (isPrivate) {
                            // PERFIL PRIVADO: Buscar posts de instagram_posts (mesmo formato)
                            const possiblePostKeys = ['instagram_posts', 'feed_real_posts'];
                            
                            let realPostsData = null;
                            
                            for (const key of possiblePostKeys) {
                                const data = localStorage.getItem(key);
                                if (data) {
                                    try {
                                        const parsed = JSON.parse(data);
                                        if (parsed && Array.isArray(parsed) && parsed.length > 0) {
                                            realPostsData = data;
                                            console.log('‚úÖ [POSTS PRIVADO] Posts encontrados na chave:', key, '-', parsed.length, 'posts');
                                            break;
                                        }
                                    } catch (e) {
                                        continue;
                                    }
                                }
                            }
                            
                            if (realPostsData) {
                                try {
                                    const parsedRealPosts = JSON.parse(realPostsData);
                                    
                                    // Processar posts do novo formato (simplificado)
                                    postsReais = parsedRealPosts.map((item, idx) => {
                                        const post = item.post;
                                        
                                        // Extrair dados diretos do novo formato
                                        let imageUrl = post.image_url || '';
                                        let videoUrl = post.video_url || '';
                                        const likes = post.like_count || 0;
                                        const comments = post.comment_count || 0;
                                        const timestamp = post.taken_at || (Date.now() / 1000);
                                        const caption = post.caption || '';
                                        
                                        // Converter media_type string para n√∫mero
                                        let mediaType = 1; // padr√£o: IMAGE
                                        if (post.media_type === 'VIDEO') {
                                            mediaType = 2;
                                        } else if (post.media_type === 'CAROUSEL') {
                                            mediaType = 8;
                                        }
                                        
                                        // Aplicar proxy apenas em imagens (v√≠deos n√£o funcionam com proxy)
                                        if (imageUrl && !imageUrl.includes('image-proxy.php') && typeof getProxyImageUrl === 'function') {
                                            imageUrl = getProxyImageUrl(imageUrl);
                                        }
                                        // V√≠deos: usar URL original da API (proxy n√£o suporta streaming)
                                        
                                        // Aspect ratio padr√£o
                                        const aspectRatio = '1 / 1';
                                        
                                        // Foto de perfil: usar diretamente do item (j√° vem da API)
                                        let profilePicUrl = item.profile_pic_url || './imagens/perfil-sem-foto.jpeg';
                                        
                                        // Aplicar proxy na foto de perfil se necess√°rio
                                        if (typeof getProxyImageUrl === 'function' && profilePicUrl && !profilePicUrl.startsWith('./') && !profilePicUrl.startsWith('../')) {
                                            profilePicUrl = getProxyImageUrl(profilePicUrl);
                                        }
                                        
                                        return {
                                            username: item.username || '',
                                            originalUsername: item.username || '',
                                            profilePic: profilePicUrl,
                                            fullName: item.full_name || '',
                                            imageUrl: imageUrl,
                                            videoUrl: videoUrl,
                                            mediaType: mediaType,
                                            likes: likes,
                                            comments: comments,
                                            reposts: 0,
                                            shares: 0,
                                            caption: caption,
                                            timestamp: timestamp,
                                            isReal: true,
                                            isFallback: false,
                                            aspectRatio: aspectRatio,
                                            locationType: 'none'
                                        };
                                    });
                                    
                                    // Gerar username aleat√≥rio para posts sem username
                                    postsReais = postsReais.map((post, idx) => {
                                        if (!post.username) {
                                            if (typeof generateRandomUsers === 'function') {
                                                const randomUsers = generateRandomUsers(1);
                                                if (randomUsers && randomUsers.length > 0) {
                                                    post.username = maskUsername(randomUsers[0].username || 'usuario');
                                                    post.originalUsername = randomUsers[0].username || 'usuario';
                                                } else {
                                                    post.username = maskUsername('usuario');
                                                    post.originalUsername = 'usuario';
                                                }
                                            } else {
                                                post.username = maskUsername('usuario');
                                                post.originalUsername = 'usuario';
                                            }
                                        }
                                        return post;
                                    });
                                    
                                    console.log('‚úÖ [POSTS PRIVADO] Posts processados:', postsReais.length);
                                } catch (e) {
                                    console.error('‚ùå [POSTS PRIVADO] Erro ao processar posts:', e);
                                }
                            }
                        } else {
                            // PERFIL P√öBLICO: Buscar posts de feed_real_posts
                            const possiblePostKeys = ['instagram_posts', 'feed_real_posts'];

                            console.log('üîç [POSTS P√öBLICO] Tentando buscar posts nas chaves:', possiblePostKeys);

                            let realPostsData = null;
                            let usedPostKey = null;

                            for (const key of possiblePostKeys) {
                                const data = localStorage.getItem(key);
                                if (data) {
                                    try {
                                        const parsed = JSON.parse(data);
                                        if (parsed && Array.isArray(parsed) && parsed.length > 0) {
                                            realPostsData = data;
                                            usedPostKey = key;
                                            console.log('‚úÖ [POSTS P√öBLICO] Posts encontrados na chave:', key, '-', parsed.length, 'posts');
                                            break;
                                        }
                                    } catch (e) {
                                        console.warn(`‚ö†Ô∏è [POSTS P√öBLICO] Erro ao parsear chave ${key}:`, e);
                                        continue;
                                    }
                                }
                            }
                            
                            if (realPostsData) {
                                try {
                                    const parsedRealPosts = JSON.parse(realPostsData);
                                    console.log('‚úÖ [POSTS P√öBLICO] Posts reais encontrados no localStorage:', parsedRealPosts.length);
                                    console.log('üîç [DEBUG] parsedRealPosts usernames:', parsedRealPosts.map(p => p.username));

                                    // Processar posts do novo formato (simplificado)
                                    postsReais = parsedRealPosts.map((item, idx) => {
                                        const post = item.post;
                                        console.log('üîç [DEBUG] Processando post:', idx, '| item.username:', item.username);
                                        
                                        // Extrair dados diretos do novo formato
                                        let imageUrl = post.image_url || '';
                                        let videoUrl = post.video_url || '';
                                        const likes = post.like_count || 0;
                                        const comments = post.comment_count || 0;
                                        const timestamp = post.taken_at || (Date.now() / 1000);
                                        const caption = post.caption || '';
                                        
                                        // Converter media_type string para n√∫mero
                                        let mediaType = 1; // padr√£o: IMAGE
                                        if (post.media_type === 'VIDEO') {
                                            mediaType = 2;
                                        }
                                        
                                        // Aplicar proxy apenas em imagens (v√≠deos n√£o funcionam com proxy)
                                        if (imageUrl && !imageUrl.includes('image-proxy.php') && typeof getProxyImageUrl === 'function') {
                                            imageUrl = getProxyImageUrl(imageUrl);
                                        }
                                        // V√≠deos: usar URL original da API (proxy n√£o suporta streaming)
                                        
                                        // Aspect ratio padr√£o
                                        const aspectRatio = '1 / 1';
                                        
                                        // Foto de perfil e username: usar diretamente do item (j√° vem da API)
                                        let profilePicUrl = item.profile_pic_url || './imagens/perfil-sem-foto.jpeg';
                                        let postUsername = item.username || '';
                                        
                                        // Aplicar proxy na foto de perfil se necess√°rio
                                        if (typeof getProxyImageUrl === 'function' && profilePicUrl && !profilePicUrl.startsWith('./') && !profilePicUrl.startsWith('../')) {
                                            profilePicUrl = getProxyImageUrl(profilePicUrl);
                                        }
                                        
                                        return {
                                            username: postUsername,
                                            originalUsername: postUsername,
                                            profilePic: profilePicUrl,
                                            fullName: item.full_name || '',
                                            imageUrl: imageUrl,
                                            videoUrl: videoUrl,
                                            mediaType: mediaType,
                                            likes: likes,
                                            comments: comments,
                                            reposts: 0,
                                            shares: 0,
                                            caption: caption,
                                            timestamp: timestamp,
                                            isReal: true,
                                            isFallback: false,
                                            aspectRatio: aspectRatio,
                                            locationType: 'none'
                                        };
                                    });

                                    // Gerar username aleat√≥rio para posts sem username
                                    postsReais = postsReais.map((post, idx) => {
                                        if (!post.username) {
                                            if (typeof generateRandomUsers === 'function') {
                                                const randomUsers = generateRandomUsers(1);
                                                if (randomUsers && randomUsers.length > 0) {
                                                    post.username = maskUsername(randomUsers[0].username || 'usuario');
                                                    post.originalUsername = randomUsers[0].username || 'usuario';
                                                } else {
                                                    post.username = maskUsername('usuario');
                                                    post.originalUsername = 'usuario';
                                                }
                                            } else {
                                                post.username = maskUsername('usuario');
                                                post.originalUsername = 'usuario';
                                            }
                                        }
                                        return post;
                                    });
                                    
                                    console.log('‚úÖ [POSTS P√öBLICO] Posts processados:', postsReais.length);
                                } catch (e) {
                                    console.error('‚ùå [POSTS P√öBLICO] Erro ao processar posts:', e);
                                }
                            } else {
                                console.warn('‚ö†Ô∏è [POSTS P√öBLICO] feed_real_posts n√£o encontrado. Chaves tentadas:', possiblePostKeys);
                            }
                        }
                    } catch (e) {
                        console.warn('‚ö†Ô∏è Erro ao processar posts reais:', e);
                    }
                    
                    let needFallback = Math.max(0, 6 - postsReais.length);

                    // NUNCA criar s√≥ 1 fallback - se precisar de 1, criar 2
                    if (needFallback === 1) {
                        needFallback = 2;
                    }

                    // Criar availableUsers para fallback (gerar aleatoriamente)
                    // console.log('üîÑ [POSTS] Criando availableUsers para fallback...');
                    const availableUsers = [];
                    if (typeof generateRandomUsers === 'function') {
                        // console.log('‚úÖ [POSTS] generateRandomUsers dispon√≠vel para fallback');
                        const randomUsers = generateRandomUsers(20);
                        // console.log('üì¶ [POSTS] randomUsers para fallback:', randomUsers.length);
                        randomUsers.forEach(profile => {
                        if (profile && profile.username) {
                            // N√£o usar perfis que j√° t√™m post real
                            const alreadyHasPost = postsReais.some(p => p.username === profile.username);
                                if (!alreadyHasPost) {
                                    // Usar foto de perfil real da API
                                    let profilePic = profile.profile_pic_url || './imagens/perfil-sem-foto.jpeg';
                                    if (typeof getProxyImageUrl === 'function' && profilePic && !profilePic.startsWith('../')) {
                                        profilePic = getProxyImageUrl(profilePic);
                                    }
                                availableUsers.push({
                                    username: profile.username,
                                    profilePic: profilePic,
                                    fullName: profile.full_name || '',
                                });
                            }
                        }
                        });
                    }

                    // Embaralhar availableUsers
                    const shuffledUsers = [...availableUsers].sort(() => Math.random() - 0.5);

                    // 5. CRIAR POSTS FALLBACK (se necess√°rio)
                    // console.log('üîÑ [POSTS] Criando posts fallback...');
                    const fallbackPosts = [];
                    // console.log('üìä [POSTS] needFallback:', needFallback, '| shuffledUsers.length:', shuffledUsers.length);

                    if (needFallback > 0 && shuffledUsers.length > 0) {
                        // console.log('‚úÖ [POSTS] Criando', needFallback, 'posts fallback...');
                        /*
                         * L√ìGICA DE INTERCALA√á√ÉO DE POSTS:
                         * ================================
                         * Posts reais + fallback s√£o intercalados por data para parecer natural.
                         *
                         * Exemplo:
                         * - Posts reais: dia 1, dia 10, dia 20
                         * - Fallback calculado: dia 5 (entre 1-10), dia 15 (entre 10-20)
                         *
                         * Resultado final ordenado por timestamp (mais recente primeiro):
                         * dia 20 (real) ‚Üí dia 15 (fallback) ‚Üí dia 10 (real) ‚Üí dia 5 (fallback) ‚Üí dia 1 (real)
                         *
                         * Post da Choquei SEMPRE fica na 3¬™ posi√ß√£o, independente da data.
                         */
                        let fallbackDates = [];

                        if (postsReais.length >= 2) {
                            // Ordenar posts reais por timestamp (mais recente primeiro)
                            const sortedRealPosts = [...postsReais].sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));

                            // Calcular datas intermedi√°rias entre cada par de posts reais
                            for (let i = 0; i < sortedRealPosts.length - 1 && fallbackDates.length < needFallback; i++) {
                                const newerPost = sortedRealPosts[i].timestamp || 0;
                                const olderPost = sortedRealPosts[i + 1].timestamp || 0;
                                // Data intermedi√°ria = m√©dia entre os dois posts
                                const midDate = (newerPost + olderPost) / 2;
                                fallbackDates.push(midDate);
                            }

                            // Se ainda precisa de mais datas, criar antes do post mais antigo
                            while (fallbackDates.length < needFallback) {
                                const oldestPost = sortedRealPosts[sortedRealPosts.length - 1].timestamp || (Date.now() / 1000);
                                const daysBeforeOldest = (fallbackDates.length + 1) * 3 * 86400; // 3, 6, 9 dias antes
                                fallbackDates.push(oldestPost - daysBeforeOldest);
                            }
                        } else if (postsReais.length === 1) {
                            // Um post real: criar fallback antes e depois
                            const realTimestamp = postsReais[0].timestamp || (Date.now() / 1000);
                            for (let i = 0; i < needFallback; i++) {
                                const offset = (i % 2 === 0 ? 1 : -1) * ((Math.floor(i / 2) + 1) * 3 * 86400);
                                fallbackDates.push(realTimestamp + offset);
                            }
                        } else {
                            // Sem posts reais: distribuir nos √∫ltimos 30 dias
                            const nowTimestamp = Date.now() / 1000;
                            for (let i = 0; i < needFallback; i++) {
                                const daysAgo = (i + 1) * 4 * 86400; // 4, 8, 12, 16 dias atr√°s
                                fallbackDates.push(nowTimestamp - daysAgo);
                            }
                        }

                        // Criar posts fallback com as datas calculadas
                        const captions = [
                            'ü©∑',
                            'deu certo',
                            'casa cmg???',
                            'üíï',
                            'üéâ',
                            '‚ù§Ô∏è',
                            'üòä',
                            '‚ú®',
                            'üòç',
                            'üî•üíØ',
                            'üí™üî•',
                            'üéØ',
                            '',
                            '',
                            '',
                            '',
                            '',
                            ''
                        ];

                        for (let i = 0; i < needFallback && i < shuffledUsers.length; i++) {
                            const user = shuffledUsers[i];
                            // 30% chance de n√£o ter caption, 20% chance de ter s√≥ emojis, 50% chance de ter texto normal
                            const captionType = Math.random();
                            let randomCaption = '';

                            if (captionType < 0.3) {
                                // 30% sem caption
                                randomCaption = '';
                            } else if (captionType < 0.5) {
                                // 20% s√≥ emojis
                                const emojiOnly = ['üî•üíØ', '‚ú®', 'üòç‚ù§Ô∏è', 'üéØ', 'üí™üî•', 'ü©∑‚ú®', 'üí´', 'üåü', 'üòéüî•'];
                                randomCaption = emojiOnly[Math.floor(Math.random() * emojiOnly.length)];
                            } else {
                                // 50% texto normal (pode ser curto ou longo)
                                randomCaption = captions[Math.floor(Math.random() * captions.length)];
                            }
                            // Gerar curtidas primeiro
                            const likes = Math.floor(Math.random() * 180) + 20;

                            // Coment√°rios proporcionais √†s curtidas (5-15% das curtidas, mas alguns posts podem n√£o ter)
                            const hasComments = Math.random() > 0.2; // 80% dos posts t√™m coment√°rios
                            const comments = hasComments ? Math.floor(likes * (0.05 + Math.random() * 0.10)) : 0;

                            // Reposts proporcionais (alguns posts n√£o t√™m)
                            const hasReposts = Math.random() > 0.4; // 60% dos posts t√™m reposts
                            const reposts = hasReposts ? Math.floor(likes * (0.02 + Math.random() * 0.08)) : 0;

                            // Shares (encaminhamentos) - alguns podem n√£o ter
                            const hasShares = Math.random() > 0.3; // 70% dos posts t√™m shares
                            const shares = hasShares ? Math.floor(likes * (0.01 + Math.random() * 0.05)) : 0;

                            // Distribuir tipos de localiza√ß√£o de forma fixa e c√≠clica:
                            // A cada 5 posts: 2 neighbor_city, 1 ip_city, 1 famous_place, 1 none
                            const cyclePosition = i % 5;
                            let locationType = 'none';
                            if (cyclePosition === 0 || cyclePosition === 1) {
                                locationType = 'neighbor_city'; // Posi√ß√µes 0 e 1: cidades vizinhas
                            } else if (cyclePosition === 2) {
                                locationType = 'ip_city'; // Posi√ß√£o 2: cidade do IP
                            } else if (cyclePosition === 3) {
                                locationType = 'famous_place'; // Posi√ß√£o 3: local famoso
                            } // cyclePosition === 4: sem localiza√ß√£o

                            fallbackPosts.push({
                                username: maskUsername(user.username),
                                profilePic: user.profilePic || './imagens/perfil-sem-foto.jpeg',
                                fullName: user.fullName,
                                imageUrl: '',
                                likes: likes,
                                comments: comments,
                                reposts: reposts,
                                shares: shares,
                                caption: randomCaption,
                                timestamp: fallbackDates[i] || (Date.now() / 1000),
                                isReal: false,
                                isFallback: true,
                                hideComments: false,
                                hideCaption: false,
                                aspectRatio: Math.random() > 0.5 ? '1 / 1' : '3 / 2',
                                locationType: locationType
                            });
                        }
                    }

                    // 6. COMBINAR POSTS REAIS + FALLBACK e ORDENAR POR TIMESTAMP (mais recente primeiro)
                    console.log('üîÑ [POSTS] Combinando posts...');
                    console.log('üìä [POSTS] postsReais:', postsReais.length, '| fallbackPosts:', fallbackPosts.length);
                    let allPosts = [...postsReais, ...fallbackPosts];
                    console.log('üì¶ [POSTS] Total allPosts ap√≥s combinar:', allPosts.length);
                    
                    // Ordenar por timestamp (mais recente primeiro)
                    allPosts.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
                    console.log('‚úÖ [POSTS] Posts ordenados por data (mais recente primeiro)');

                    // 8. CONVERTER PARA FORMATO ESPERADO PELO C√ìDIGO DE RENDERIZA√á√ÉO
                    // console.log('üîÑ [POSTS] Convertendo para formato de renderiza√ß√£o...');
                    // Criar mapa de perfis para buscar profilePic e fullName (usar allUsers dos stories)
                    const profilesMap = new Map();
                    // console.log('üìä [POSTS] Criando profilesMap com', allUsers.length, 'usu√°rios');
                    allUsers.forEach(profile => {
                        if (profile.username) {
                            // Aplicar proxy √† foto de perfil
                            let profilePicProxy = profile.profile_pic_url || './imagens/perfil-sem-foto.jpeg';
                            if (typeof getProxyImageUrl === 'function' && profilePicProxy && !profilePicProxy.startsWith('../')) {
                                profilePicProxy = getProxyImageUrl(profilePicProxy);
                            }
                            profilesMap.set(profile.username.toLowerCase(), {
                                profilePic: profilePicProxy,
                                fullName: profile.full_name || '',
                            });
                        }
                    });

                    // console.log('üîÑ [POSTS] Mapeando allPosts para postsData...');
                    postsData = allPosts.map(post => {
                        // Buscar dados do perfil se for post real
                        let profilePic = post.profilePic || './imagens/perfil-sem-foto.jpeg';
                        let fullName = post.fullName || '';
                        if (post.isReal) {
                            // Buscar dados do perfil nos seguidores/chaining
                            const lookupUsername = (post.originalUsername || post.username || '').toLowerCase();
                            console.log('üîç [DEBUG] Buscando perfil para:', lookupUsername, '| allUsers:', allUsers.length);
                            console.log('üîç [DEBUG] Primeiros 3 allUsers:', allUsers.slice(0, 3).map(u => u.username));
                            
                            // 1. Primeiro tentar buscar em allUsers (seguidores/chaining) - PRIORIDADE
                            const userData = allUsers.find(u => (u.username || '').toLowerCase() === lookupUsername);
                            if (userData) {
                                profilePic = userData.profile_pic_url || './imagens/perfil-sem-foto.jpeg';
                                fullName = userData.full_name || '';
                            } else {
                                // 2. Tentar buscar no profilesMap (fallback)
                                const profileData = profilesMap.get(lookupUsername);
                                if (profileData) {
                                    profilePic = profileData.profilePic || './imagens/perfil-sem-foto.jpeg';
                                    fullName = profileData.fullName;
                                } else {
                                    // 3. √öltimo recurso: buscar diretamente em followers/chaining do localStorage
                                    try {
                                        const followersData = localStorage.getItem('instagram_followers') || localStorage.getItem('followers');
                                        const chainingData = localStorage.getItem('chaining_results');
                                        
                                        // Tentar em followers primeiro
                                        if (followersData) {
                                            const followers = JSON.parse(followersData);
                                            const matchingFollower = followers.find(f => 
                                                f.username && f.username.toLowerCase() === lookupUsername
                                            );
                                            if (matchingFollower) {
                                                profilePic = matchingFollower.profile_pic_url || './imagens/perfil-sem-foto.jpeg';
                                                fullName = matchingFollower.full_name || '';
                                            }
                                        }
                                        
                                        // Se ainda n√£o encontrou, tentar em chaining
                                        if (profilePic === './imagens/perfil-sem-foto.jpeg' && chainingData) {
                                            const chaining = JSON.parse(chainingData);
                                            const matchingChaining = chaining.find(c => 
                                                c.username && c.username.toLowerCase() === lookupUsername
                                            );
                                            if (matchingChaining) {
                                                profilePic = matchingChaining.profile_pic_url || './imagens/perfil-sem-foto.jpeg';
                                                fullName = matchingChaining.full_name || '';
                                            }
                                        }
                                    } catch (e) {
                                        console.warn('‚ö†Ô∏è [POST] Erro ao buscar perfil para:', lookupUsername, e);
                                    }
                                }
                            }
                        }
                        // Aplicar proxy √† foto de perfil se necess√°rio
                        if (typeof getProxyImageUrl === 'function' && profilePic && !profilePic.startsWith('../')) {
                            profilePic = getProxyImageUrl(profilePic);
                        }

                        // Usar valores do post se existirem, sen√£o manter como est√£o (podem ser 0)
                        const comments = post.comments !== undefined ? post.comments : 0;
                        const reposts = post.reposts !== undefined ? post.reposts : 0;
                        const shares = post.shares !== undefined ? post.shares : 0;
                        const caption = post.caption || '';

                        return {
                            username: post.isReal ? post.username : maskUsername(post.username),
                            profilePic: profilePic,
                            fullName: fullName,
                            imageUrl: post.imageUrl,
                            videoUrl: post.videoUrl || '',
                            mediaType: post.mediaType || post.media_type || '',
                            likes: post.likes || Math.floor(Math.random() * 180) + 20,
                            comments: comments,
                            reposts: reposts,
                            shares: shares,
                            liked: Math.random() > 0.5,
                            saved: Math.random() > 0.7,
                            caption: caption,
                            date: formatPostDate(post.timestamp),
                            timestamp: post.timestamp,
                            aspectRatio: post.aspectRatio || '1 / 1',
                            verified: post.verified || false,
                            isReal: post.isReal || false,
                            isFallback: post.isFallback || false,
                            hideComments: false,
                            hideCaption: false,
                            locationType: post.locationType || 'none'
                        };
                    });
                    sessionStorage.setItem(sessionPostsKey, JSON.stringify(postsData));
                }

                // Fun√ß√£o para formatar n√∫meros grandes (estilo Instagram)
                function formatNumber(num) {
                    if (num >= 1000000) {
                        // Para n√∫meros >= 1 milh√£o, usar "mi" (ex: 2,4 mi, 12 mi)
                        const mi = (num / 1000000).toFixed(1);
                        const formatted = mi.replace('.', ',').replace(',0', '');
                        return formatted + ' mi';
                    } else if (num >= 10000) {
                        // Para n√∫meros >= 10000 e < 1 milh√£o, usar "mil" (ex: 37,9 mil, 13 mil)
                        const k = (num / 1000).toFixed(1);
                        const formatted = k.replace('.', ',').replace(',0', '');
                        return formatted + ' mil';
                    } else if (num >= 1000) {
                        // Para n√∫meros entre 1000-9999, usar ponto como separador de milhar (ex: 8.491, 1.045)
                        const str = num.toString();
                        return str.slice(0, -3) + '.' + str.slice(-3);
                    }
                    return num.toString();
                }

                // Carregar todas as localiza√ß√µes primeiro
                let locations = [];
                const cityData = await detectCityByIPWithCache();
                if (!cityData) {
                    // Se n√£o conseguir pegar dados da API, todas as localiza√ß√µes ser√£o vazias
                    locations = postsData.map(() => '');
                } else {
                    // Carregar listas de localiza√ß√µes salvas
                    const neighborCitiesArray = JSON.parse(localStorage.getItem('user_neighbor_cities') || '[]');
                    const famousPlacesArray = JSON.parse(localStorage.getItem('user_famous_places') || '[]');
                    
                    console.log('üåç [LOCATIONS] Cidades vizinhas dispon√≠veis:', neighborCitiesArray.length);
                    console.log('üåç [LOCATIONS] Locais famosos dispon√≠veis:', famousPlacesArray.length);

                    // Contadores para distribuir localiza√ß√µes sem repetir
                    let neighborCityIndex = 0;
                    let famousPlaceIndex = 0;

                    // Atribuir localiza√ß√µes aos posts
                    locations = postsData.map((post, index) => {
                        const locationType = post.locationType || 'none';
                        
                        if (locationType === 'none') return ''; // Sem localiza√ß√£o

                        if (locationType === 'ip_city') {
                            return cityData.cidade || '';
                        }

                        if (locationType === 'neighbor_city') {
                            // Pegar pr√≥xima cidade vizinha dispon√≠vel (sem repetir)
                            if (neighborCitiesArray.length > 0) {
                                const city = neighborCitiesArray[neighborCityIndex % neighborCitiesArray.length];
                                neighborCityIndex++;
                                return city;
                            }
                            return cityData.cidade || '';
                        }

                        if (locationType === 'famous_place') {
                            // Pegar pr√≥ximo local famoso dispon√≠vel (sem repetir)
                            if (famousPlacesArray.length > 0) {
                                const place = famousPlacesArray[famousPlaceIndex % famousPlacesArray.length];
                                famousPlaceIndex++;
                                return place;
                            }
                            return cityData.cidade || '';
                        }

                        // Para 'hidden', retorna vazio (n√£o "Local Oculto")
                        return '';
                    });
                    
                    console.log('‚úÖ Localiza√ß√µes:', locations.filter(l => l).length, 'posts');
                }

                // Manter a ordem original dos posts, apenas as fotos s√£o aleat√≥rias
                // console.log('üé® [POSTS] Renderizando posts no HTML...');
                // console.log('üìä [POSTS] postsData.length:', postsData.length);
                // console.log('üîç [POSTS] postsData √© null?', postsData === null);
                // console.log('üîç [POSTS] postsData √© array?', Array.isArray(postsData));
                if (!postsData || postsData.length === 0) {
                    console.error('‚ùå [POSTS] postsData est√° vazio ou null! N√£o h√° posts para renderizar.');
                    // console.log('üîç [POSTS] Verificando se posts foram gerados corretamente...');
                    // console.log('üîç [POSTS] allUsers.length:', allUsers.length);
                    // console.log('üîç [POSTS] generateRandomUsers dispon√≠vel?', typeof generateRandomUsers === 'function');
                    postsContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #F9F9F9;">‚ö†Ô∏è Nenhum post dispon√≠vel</div>';
                    return;
                } else {
                    console.log('‚úÖ Feed carregado:', postsData.length, 'posts');
                }
                
                // Constante: 1 ano em segundos
                const now = Date.now() / 1000; // timestamp atual em segundos
                const oneYearInSeconds = 365 * 86400; // 365 dias em segundos
                
                postsContainer.innerHTML = postsData.map((post, index) => {
                    // Mostrar data apenas para posts com menos de 1 ano
                    let relativeTime = '';
                    if (post.timestamp) {
                        const postAge = now - post.timestamp;
                        if (postAge < oneYearInSeconds) {
                            relativeTime = post.date || 'Agora';
                        }
                    } else {
                        relativeTime = post.date || 'Agora';
                    }

                    // Calcular hor√°rio baseado no timestamp (se dispon√≠vel)
                    let time = '00:00';
                    if (post.timestamp) {
                        const postDate = new Date(post.timestamp * 1000);
                        const hours = postDate.getHours().toString().padStart(2, '0');
                        const minutes = postDate.getMinutes().toString().padStart(2, '0');
                        time = `${hours}:${minutes}`;
                    }

                    const formattedDate = post.date || '';

                    // Se for post REAL, usar imageUrl/videoUrl da API; se FALLBACK, n√£o mostrar m√≠dia
                    let postImageUrl = '';
                    let postVideoUrl = '';
                    const postMediaType = post.mediaType || post.media_type;
                    if (post.isReal && (post.imageUrl || post.videoUrl)) {
                        // Post real: usar imagem ou v√≠deo do post da API
                        postImageUrl = post.imageUrl || '';
                        postVideoUrl = post.videoUrl || '';
                        
                        // Se for v√≠deo e n√£o tiver imagem, usar a mesma URL do v√≠deo como poster
                        if (postVideoUrl && !postImageUrl) {
                            postImageUrl = postVideoUrl;
                        }
                    }
                    // Posts fallback: postImageUrl/postVideoUrl ficam vazios (apenas conte√∫do restrito)

                    // Foto de perfil do usu√°rio (sempre usar profilePic para o avatar)
                    let postProfilePic = post.profilePic || './imagens/perfil-sem-foto.jpeg';
                    // Aplicar proxy se necess√°rio
                    if (typeof getProxyImageUrl === 'function' && postProfilePic && !postProfilePic.startsWith('../')) {
                        postProfilePic = getProxyImageUrl(postProfilePic);
                    }

                    // Obter localiza√ß√£o do array carregado (vazio se n√£o houver)
                    const locationText = locations[index] || '';

                    // Formatar n√∫meros (sempre mostrar, exceto se for 0)
                    const formattedLikes = (post.likes && post.likes > 0) ? formatNumber(post.likes) : '';
                    const formattedComments = (post.comments && post.comments > 0) ? formatNumber(post.comments) : '';
                    const formattedReposts = (post.reposts && post.reposts > 0) ? formatNumber(post.reposts) : '';
                    const formattedShares = (post.shares && post.shares > 0) ? formatNumber(post.shares) : '';

                    // Username com m√°scara (igual aos stories)
                    const displayUsername = typeof maskUsername === 'function' ? maskUsername(post.username || post.originalUsername || 'usuario') : post.username;
                    const showVerified = post.verified;

                    return `
                        <div class="post-container" style="background: rgb(11, 16, 20); margin-bottom: 16px;">
                            <div style="padding: 12px 16px; display: flex; align-items: center; justify-content: space-between;">
                                <button style="display: flex; align-items: center; gap: 12px; background: none; border: none; cursor: pointer;">
                                    <div style="width: 32px; height: 32px; border-radius: 50%; overflow: hidden; background: rgb(31, 41, 55); position: relative;">
                                        ${post.locked ? `
                                            <img alt="${post.username}" src="https://meustalker.vercel.app/${postProfilePic}" style="width: 100%; height: 100%; object-fit: cover; filter: blur(4px); opacity: 0.8;">
                                            <div style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.4);">
                                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 12px; height: 12px; color: #F9F9F9;">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path>
                                                </svg>
                                            </div>
                                        ` : `
                                            <img alt="${post.username}" src="https://meustalker.vercel.app/${postProfilePic}" style="width: 100%; height: 100%; object-fit: cover; opacity: 0.8;" loading="lazy" decoding="async">
                                        `}
                                    </div>
                                    <div style="text-align: left;">
                                        <div style="display: flex; align-items: center; gap: 4px;">
                                            <p style="font-size: 14px; font-weight: 600; color: #F9F9F9; margin: 0;">${displayUsername}</p>
                                            ${showVerified ? `<img src="https://meustalker.vercel.app/imagens/verificado-ig.png" alt="Verificado" style="width: 12px; height: 12px; flex-shrink: 0; object-fit: contain;" loading="lazy" decoding="async">` : ''}
                                        </div>
                                        ${locationText ? `<p style="font-size: 12px; color: rgb(156, 163, 175); margin: 0;">${locationText}</p>` : ''}
                                    </div>
                                </button>
                                <button class="blocked-action" style="background: none; border: none; cursor: pointer;">
                                    <svg fill="currentColor" viewBox="0 0 24 24" style="width: 20px; height: 20px; color: #F9F9F9;">
                                        <circle cx="12" cy="5" r="1.5"></circle>
                                        <circle cx="12" cy="12" r="1.5"></circle>
                                        <circle cx="12" cy="19" r="1.5"></circle>
                                    </svg>
                                </button>
                            </div>
                            <div class="post-image-container" style="width: 100%; aspect-ratio: ${post.aspectRatio}; background: rgb(18, 24, 34); display: flex; flex-direction: column; align-items: center; justify-content: center; border-radius: 0; position: relative; overflow: hidden;">
                                ${postVideoUrl ? `
                                    <video 
                                        id="video-${post.id || Math.random().toString(36).substr(2, 9)}"
                                        src="https://meustalker.vercel.app/${postVideoUrl}" 
                                        playsinline
                                        loop
                                        muted
                                        preload="none"
                                        disablePictureInPicture
                                        controlsList="nodownload nofullscreen noremoteplayback"
                                        oncontextmenu="return false;"
                                        style="width: 100%; height: 100%; object-fit: cover; cursor: pointer; image-rendering: optimizeSpeed; user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; background-color: #000; background-image: url('${postImageUrl || ''}'); background-size: cover; background-position: center;"
                                        poster="https://meustalker.vercel.app/${postImageUrl || ''}"
                                        onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                                        Seu navegador n√£o suporta v√≠deos.
                                    </video>
                                    <!-- Controles Instagram style -->
                                    <div class="video-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;">
                                        <!-- Bot√£o de Mute/Unmute no canto inferior direito (estilo Instagram) -->
                                        <button class="video-mute-btn" data-video-id="video-${post.id || Math.random().toString(36).substr(2, 9)}" style="position: absolute; bottom: 16px; right: 16px; width: 24px; height: 24px; border-radius: 50%; background: rgba(60, 60, 60, 0.75); border: none; display: flex; align-items: center; justify-content: center; cursor: pointer; pointer-events: auto; z-index: 10; padding: 0;">
                                            <!-- √çcone de som ativo (quando N√ÉO est√° mutado) -->
                                            <svg class="sound-icon" width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
                                                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5" fill="white"></polygon>
                                                <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                                                <path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
                                            </svg>
                                            <!-- √çcone de mute (mesmo que som ativo + linha diagonal) -->
                                            <svg class="muted-icon" width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: block;">
                                                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5" fill="white"></polygon>
                                                <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                                                <path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
                                                <line x1="2" y1="2" x2="22" y2="22" stroke-width="2.2"></line>
                                            </svg>
                                        </button>
                                    </div>
                                    <div style="display: none; width: 100%; height: 100%; background: rgb(18, 24, 34); flex-direction: column; align-items: center; justify-content: center;">
                                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 48px; height: 48px; color: rgb(107, 114, 128); margin-bottom: 12px;">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path>
                                        </svg>
                                        <p style="color: rgb(156, 163, 175); font-weight: 500; margin: 0;">Conte√∫do restrito</p>
                                    </div>
                                ` : postImageUrl ? `
                                    <img src="https://meustalker.vercel.app/${postImageUrl}" alt="Post de ${post.username}" style="width: 100%; height: 100%; object-fit: cover; image-rendering: optimizeSpeed;" loading="lazy" decoding="async" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                                    <div style="display: none; width: 100%; height: 100%; background: rgb(18, 24, 34); flex-direction: column; align-items: center; justify-content: center;">
                                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 48px; height: 48px; color: rgb(107, 114, 128); margin-bottom: 12px;">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path>
                                        </svg>
                                        <p style="color: rgb(156, 163, 175); font-weight: 500; margin: 0;">Conte√∫do restrito</p>
                                    </div>
                                ` : `
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 48px; height: 48px; color: rgb(107, 114, 128); margin-bottom: 12px;">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path>
                                    </svg>
                                    <p style="color: rgb(156, 163, 175); font-weight: 500; margin: 0;">Conte√∫do restrito</p>
                                    ${formattedDate && relativeTime ? `<p style="color: rgb(107, 114, 128); font-size: 14px; margin-top: 4px;">${formattedDate} - ${time}</p>` : ''}
                                `}
                            </div>
                            <div style="padding: 12px 16px;">
                                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                                    <div style="display: flex; align-items: center; gap: 16px;">
                                        <button class="like-button" data-post-index="${index}" data-liked="${post.liked}" style="display: flex; align-items: center; gap: 4px; background: none; border: none; cursor: pointer;">
                                            <img alt="Curtir" src="https://meustalker.vercel.app/svg/${post.liked&#32;?&#32;'coracao-curtido'&#32;:&#32;'coracao'}.svg" style="width: 26px; height: 26px;">
                                            ${formattedLikes ? `<span class="likes-count-display" style="font-size: 14px; font-weight: 600; color: #F9F9F9;">${formattedLikes}</span>` : ''}
                                        </button>
                                        <button class="blocked-action" style="display: flex; align-items: center; gap: 4px; background: none; border: none; cursor: pointer;">
                                            <img alt="Comentar" src="svg/comentario.svg" style="width: 24px; height: 24px;">
                                            ${formattedComments ? `<span style="font-size: 14px; font-weight: 600; color: #F9F9F9;">${formattedComments}</span>` : ''}
                                        </button>
                                        ${post.username === 'choqu**' ? '' : `
                                        <button class="blocked-action" style="display: flex; align-items: center; gap: 4px; background: none; border: none; cursor: pointer;">
                                            <img alt="Repost" src="svg/repost.svg" style="width: 24px; height: 24px;">
                                            ${formattedReposts ? `<span style="font-size: 14px; font-weight: 600; color: #F9F9F9;">${formattedReposts}</span>` : ''}
                                        </button>
                                        `}
                                        <button class="blocked-action" style="display: flex; align-items: center; gap: 4px; background: none; border: none; cursor: pointer;">
                                            <img alt="Enviar" src="svg/enviar.svg" style="width: 24px; height: 24px;">
                                            ${formattedShares ? `<span style="font-size: 14px; font-weight: 600; color: #F9F9F9;">${formattedShares}</span>` : ''}
                                        </button>
                                    </div>
                                    <button class="save-button" data-post-index="${index}" data-saved="${post.saved}" style="background: none; border: none; cursor: pointer;">
                                        <img alt="Salvar" src="https://meustalker.vercel.app/svg/${post.saved&#32;?&#32;'salvar-salvado'&#32;:&#32;'salvar'}.svg" style="width: 24px; height: 24px;">
                                    </button>
                                </div>
                                <div style="display: flex; flex-direction: column; gap: 8px;">
                                    ${post.caption ? `<p class="caption-container" data-full-caption="${post.caption.replace(/"/g, '&quot;').replace(/\n/g, '[BR]')}" data-expanded="false" style="font-size: 14px; color: #F9F9F9; margin: 0; line-height: 1.4;"><span style="font-weight: 600;">${post.username}</span> ${post.caption.length > 80 ? post.caption.substring(0, 80).replace(/\n/g, ' ').trim() + '...' : post.caption.replace(/\n/g, '<br>')}${post.caption.length > 80 ? ` <span class="show-more-btn" style="color: rgb(156, 163, 175); cursor: pointer;">mais</span>` : ''}</p>` : ''}
                                    ${relativeTime ? `<p style="font-size: 12.32px; color: rgb(156, 163, 175); margin: 0;">${relativeTime}</p>` : ''}
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');

                // console.log('‚úÖ [POSTS] Posts renderizados no HTML:', postsData.length);

                // N√£o salvar no sessionStorage - renderizar sempre dinamicamente

                // ===== EVENT LISTENER: Bot√£o "mais" para expandir caption =====
                document.querySelectorAll('.show-more-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const captionContainer = this.closest('.caption-container');
                        if (captionContainer) {
                            const fullCaption = captionContainer.getAttribute('data-full-caption');
                            const username = captionContainer.querySelector('span[style*="font-weight: 600"]');
                            if (fullCaption && username) {
                                // Converter [BR] de volta para <br> para preservar quebras de linha
                                const formattedCaption = fullCaption.replace(/\[BR\]/g, '<br>');
                                captionContainer.innerHTML = `<span style="font-weight: 600;">${username.textContent}</span> ${formattedCaption}`;
                                captionContainer.setAttribute('data-expanded', 'true');
                            }
                        }
                    });
                });

                // ===== INFINITE SCROLL: Mostrar 3 posts iniciais, +3 ao scroll com loading =====
                const allPostElements = postsContainer.querySelectorAll('.post-container');
                let visiblePosts = 3;
                let allPostsLoaded = false;

                console.log('üìä [POSTS] Total de elementos de post encontrados:', allPostElements.length);

                // Esconder posts al√©m dos 3 primeiros
                allPostElements.forEach((post, index) => {
                    if (index >= visiblePosts) {
                        post.style.display = 'none';
                    }
                });

                // Fun√ß√£o para criar skeleton loading
                function createLoadingSkeleton() {
                    const skeleton = document.createElement('div');
                    skeleton.className = 'post-loading-skeleton';
                    skeleton.innerHTML = `
                        <div class="skeleton-header">
                            <div class="skeleton-avatar"></div>
                            <div class="skeleton-username"></div>
                        </div>
                        <div class="skeleton-image"></div>
                        <div class="skeleton-actions">
                            <div class="skeleton-icon"></div>
                            <div class="skeleton-icon"></div>
                            <div class="skeleton-icon"></div>
                        </div>
                        <div class="skeleton-likes"></div>
                    `;
                    return skeleton;
                }

                // Fun√ß√£o para carregar mais posts com loading
                function loadMorePosts() {
                    if (visiblePosts >= allPostElements.length) {
                        // Todos os posts carregados - mostrar banner
                        allPostsLoaded = true;
                        const banner = document.getElementById('all-posts-seen-banner');
                        if (banner) {
                            banner.classList.add('show');
                            const urlParams = new URLSearchParams(window.location.search);
                            const currentUsername = urlParams.get('username') || localStorage.getItem('username');
                            if (currentUsername) {
                            }
                            // Scroll suave para o topo
                            setTimeout(() => {
                                window.scrollTo({ top: 0, behavior: 'smooth' });
                            }, 500);
                        }
                        return;
                    }

                    // Adicionar skeleton loading
                    const skeleton = createLoadingSkeleton();
                    postsContainer.appendChild(skeleton);

                    // Ap√≥s 800ms, remover skeleton e mostrar posts reais
                    setTimeout(() => {
                        skeleton.remove();

                        const previousVisible = visiblePosts;
                        visiblePosts = Math.min(visiblePosts + 3, allPostElements.length);

                        // Mostrar novos posts
                        for (let i = previousVisible; i < visiblePosts; i++) {
                            if (allPostElements[i]) {
                                allPostElements[i].style.display = 'block';
                            }
                        }

                        // Se carregou todos, mostrar banner
                        if (visiblePosts >= allPostElements.length) {
                            allPostsLoaded = true;
                            const banner = document.getElementById('all-posts-seen-banner');
                            if (banner) {
                                banner.classList.add('show');
                                const urlParams = new URLSearchParams(window.location.search);
                                const currentUsername = urlParams.get('username') || localStorage.getItem('username');
                                if (currentUsername) {
                                }
                                // Scroll suave para o topo
                                setTimeout(() => {
                                    window.scrollTo({ top: 0, behavior: 'smooth' });
                                }, 500);
                            }
                        }
                    }, 800);
                }

                // Listener de scroll para infinite scroll
                let loadingMore = false;
                window.addEventListener('scroll', function() {
                    if (loadingMore || allPostsLoaded) return;

                    const scrollPosition = window.scrollY + window.innerHeight;
                    const documentHeight = document.documentElement.scrollHeight;

                    // Carregar mais quando estiver a 300px do final
                    if (scrollPosition >= documentHeight - 300) {
                        loadingMore = true;
                        loadMorePosts();
                        setTimeout(() => { loadingMore = false; }, 1000);
                    }
                }, { passive: true });

                // Configurar event listeners para op√ß√µes bloqueadas ap√≥s renderizar posts
                setTimeout(setupBlockedActions, 100);
            }

                // console.log('‚úÖ [LOADFEEDDATA] loadFeedData conclu√≠do!');
        }

        // Fun√ß√£o para atualizar contador de mensagens n√£o lidas
        function updateUnreadMessagesCount() {
            // Contar apenas as mensagens n√£o lidas: Fer (chat-1), Bru (chat-3, posi√ß√£o visual 5) e itz (chat-5, posi√ß√£o visual 3)
            // Verificar se os chats foram lidos atrav√©s do localStorage
            const chat1Read = localStorage.getItem('chat-1-read');
            const chat3Read = localStorage.getItem('chat-3-read'); // Bru (posi√ß√£o visual 5)
            const chat5Read = localStorage.getItem('chat-5-read'); // itz (posi√ß√£o visual 3)

            let unreadCount = 0;

            // Chat 1 (Fer) - n√£o lido se chat-1-read n√£o for 'true'
            if (chat1Read !== 'true') {
                unreadCount++;
            }

            // Chat 3 (Bru, posi√ß√£o visual 5) - n√£o lido se chat-3-read n√£o for 'true'
            if (chat3Read !== 'true') {
                unreadCount++;
            }

            // Chat 5 (itz, posi√ß√£o visual 3) - n√£o lido se chat-5-read n√£o for 'true'
            if (chat5Read !== 'true') {
                unreadCount++;
            }

            // Atualizar badge
            const unreadCountEl = document.getElementById('unread-messages-count');
            if (unreadCountEl) {
                if (unreadCount > 0) {
                    unreadCountEl.textContent = unreadCount.toString();
                    unreadCountEl.style.display = 'flex';
                } else {
                    unreadCountEl.style.display = 'none';
                }
            }

            return unreadCount;
        }

        // Comportamento do header ao fazer scroll (igual Instagram)
        let lastScrollTop = 0;
        let scrollTimeout = null;
        const header = document.getElementById('main-header');

        function handleScroll() {
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

            if (scrollTop > lastScrollTop && scrollTop > 50) {
                // Scroll para baixo - esconder header
                if (header && !header.classList.contains('hidden')) {
                    header.classList.add('hidden');
                }
            } else if (scrollTop < lastScrollTop) {
                // Scroll para cima - mostrar header
                if (header && header.classList.contains('hidden')) {
                    header.classList.remove('hidden');
                }
            }

            lastScrollTop = scrollTop <= 0 ? 0 : scrollTop;
        }

        // Throttle do scroll para melhor performance
        window.addEventListener('scroll', function() {
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
            }
            scrollTimeout = setTimeout(handleScroll, 10);
        }, { passive: true });

        // Mostrar notifica√ß√£o Instagram iOS ap√≥s 5 segundos e deixar fixa (apenas uma vez)
        function showIOSNotification() {
            // Verificar se a notifica√ß√£o j√° foi mostrada antes para este usu√°rio
            const espionadoUsername = localStorage.getItem('espionado_username');
            const notificationKey = `ios-notification-shown-${espionadoUsername || 'default'}`;
            
            if (localStorage.getItem(notificationKey) === 'true') {
                return; // N√£o mostrar novamente para este usu√°rio
            }

            // Garantir que o DOM est√° pronto antes de verificar os elementos
            if (document.readyState === 'loading') {
                setTimeout(showIOSNotification, 1000);
                return;
            }

            const notification = document.getElementById('ios-notification');
            const profilePicContainer = document.getElementById('notification-profile-pic');
            const messageEl = document.getElementById('notification-message');

            if (!notification || !profilePicContainer || !messageEl) {
                setTimeout(showIOSNotification, 2000);
                return;
            }

            // Buscar username atual para criar chave √∫nica por usu√°rio
            const urlParams = new URLSearchParams(window.location.search);
            const currentUsername = urlParams.get('username') || 'usuario';

            if (notification && profilePicContainer && messageEl) {
                // Nome sempre ser√° Fer******
                const displayName = 'Fer******';

                // Usar logo da notifica√ß√£o
                const img = document.createElement('img');
                img.src = './imagens/Logo-notificcai.svg.png';
                img.alt = 'Instagram';
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'contain';
                profilePicContainer.innerHTML = '';
                profilePicContainer.appendChild(img);

                // Atualizar mensagem
                messageEl.innerHTML = `${displayName} enviou uma mensagem: "Oi del√≠cia, adivinha o que vc esqueceu aqui? kkkk"`;

                // Marcar como mostrada no localStorage (usando chave √∫nica por usu√°rio)
                const espionadoUsername = localStorage.getItem('espionado_username');
                const notificationKey = `ios-notification-shown-${espionadoUsername || 'default'}`;
                localStorage.setItem(notificationKey, 'true');

                // Aguardar 10 segundos antes de mostrar a notifica√ß√£o
                setTimeout(() => {
                    // Mostrar notifica√ß√£o
                    notification.classList.add('show');

                    // Atualizar contador de mensagens n√£o lidas
                    updateUnreadMessagesCount();

                    // Esconder notifica√ß√£o automaticamente ap√≥s 5 segundos
                    setTimeout(() => {
                        hideNotification();
                    }, 5000);
                }, 10000);

                // Clicar na notifica√ß√£o - redirecionar para chat 1
                notification.onclick = function() {
                    hideNotification();
                    // Salvar nome mascarado e foto padr√£o no sessionStorage antes de redirecionar
                    // Fun√ß√£o maskUsername simples (mesma l√≥gica de shared-stories.js)
                    function maskUsernameSimple(username) {
                        if (!username || username.length === 0) return 'xxx*****';
                        if (username.includes('*')) return username;
                        const visibleChars = username.length >= 3 ? username.substring(0, 3) : username;
                        return visibleChars + '*****';
                    }
                    const maskedName = maskUsernameSimple('Fernanda'); // Sempre ser√° Fer******
                    const defaultPhoto = 'https://i.pravatar.cc/150?img=2'; // Foto padr√£o do chat-1
                    sessionStorage.setItem('chat-1-user-name', maskedName);
                    sessionStorage.setItem('chat-1-user-photo', defaultPhoto);
                    // Redirecionar para chat-1.html
                    window.location.href = 'chat-1.html';
                };
            } else {
                console.error('‚ùå Elementos da notifica√ß√£o n√£o encontrados no DOM');
            }
        }

        // Fun√ß√£o para esconder a notifica√ß√£o
        function hideNotification() {
            const notification = document.getElementById('ios-notification');
            if (notification && notification.classList.contains('show')) {
                notification.classList.add('hiding');
                setTimeout(() => {
                    notification.classList.remove('show');
                    notification.classList.remove('hiding');
                }, 300);
            }
        }

        // Fun√ß√£o para verificar se chegou ao final dos posts (agora gerenciado pelo infinite scroll)
        function checkEndOfPosts() {
            // L√≥gica movida para o infinite scroll integrado
            return;
        }

        // Fun√ß√£o para verificar se o banner j√° foi mostrado e exibir automaticamente
        function checkBannerOnLoad() {
            // L√≥gica agora gerenciada pelo infinite scroll
            // Esta fun√ß√£o √© mantida para compatibilidade mas n√£o faz mais nada
                return;
        }

        // Executar quando o DOM estiver pronto (mais r√°pido que window.load)
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                // Atualizar contador de mensagens n√£o lidas
                updateUnreadMessagesCount();
                // Carregar dados imediatamente
                loadFeedData();

                // Verificar banner ap√≥s loadFeedData terminar (com delay para garantir que o DOM foi atualizado)
                setTimeout(() => {
                    checkBannerOnLoad();
                }, 500);

                // Adicionar listener de scroll para detectar fim dos posts
                let scrollTimeout;
                window.addEventListener('scroll', function() {
                    clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(checkEndOfPosts, 100);
                });
                // Configurar event listeners ap√≥s um pequeno delay
                setTimeout(setupBlockedActions, 100);
                // Mostrar notifica√ß√£o ap√≥s 10 segundos (apenas uma vez)
                setTimeout(showIOSNotification, 10000);
            });
        } else {
            // DOM j√° est√° pronto
            // Atualizar contador de mensagens n√£o lidas
            updateUnreadMessagesCount();
            loadFeedData();

            // Verificar banner ap√≥s loadFeedData terminar
            setTimeout(() => {
                checkBannerOnLoad();
            }, 500);

            // Adicionar listener de scroll para detectar fim dos posts
            let scrollTimeout;
            window.addEventListener('scroll', function() {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(checkEndOfPosts, 100);
            });

            setTimeout(setupBlockedActions, 100);
            // Atualizar contador novamente
            updateUnreadMessagesCount();
            // Mostrar notifica√ß√£o ap√≥s 10 segundos (apenas uma vez)
            setTimeout(showIOSNotification, 10000);
        }

        // Banner de pr√©via gr√°tis com timer de 10 minutos
        (function() {
            const PREVIEW_DURATION = 10 * 60 * 1000; // 10 minutos em milissegundos
            const STORAGE_KEY = 'previewStartTime';

            function formatTime(ms) {
                const totalSeconds = Math.floor(ms / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }

            function initPreviewBanner() {
                // Verificar se j√° existe tempo salvo
                let startTime = localStorage.getItem(STORAGE_KEY);

                if (!startTime) {
                    // Primeira vez - salvar tempo atual
                    startTime = Date.now();
                    localStorage.setItem(STORAGE_KEY, startTime.toString());
                } else {
                    startTime = parseInt(startTime);
                }

                const elapsed = Date.now() - startTime;
                const remaining = PREVIEW_DURATION - elapsed;

                if (remaining <= 0) {
                    // Tempo esgotado - esconder banner
                    const banner = document.getElementById('preview-banner');
                    if (banner) {
                        banner.classList.add('hidden');
                        setTimeout(() => {
                            banner.remove();
                        }, 400);
                    }
                    localStorage.removeItem(STORAGE_KEY);
                    return;
                }

                // Atualizar timer inicial
                const timerText = document.getElementById('timer-text');
                if (timerText) {
                    timerText.textContent = formatTime(remaining);
                }

                // Atualizar timer a cada segundo
                const timerInterval = setInterval(() => {
                    const elapsed = Date.now() - startTime;
                    const remaining = PREVIEW_DURATION - elapsed;

                    if (remaining <= 0) {
                        clearInterval(timerInterval);
                        localStorage.removeItem(STORAGE_KEY);
                        // Redirecionar para CTA quando timer zerar
                        goToCTA();
                        return;
                    } else {
                        const timerText = document.getElementById('timer-text');
                        if (timerText) {
                            timerText.textContent = formatTime(remaining);
                        }
                    }
                }, 1000);
            }

            // Inicializar quando o DOM estiver pronto
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initPreviewBanner);
            } else {
                initPreviewBanner();
            }
        })();

        // Reproduzir √°udio do cron√¥metro nos primeiros segundos
        (function() {
            const STORAGE_KEY = 'instagram_preview_expiry';
            const PREVIEW_DURATION = 10 * 60 * 1000; // 10 minutos em ms
            const AUDIO_DURATION = 10; // Dura√ß√£o do √°udio em segundos
            
            // Verificar se deve tocar o √°udio
            const shouldPlayAudio = () => {
                const expiryTime = localStorage.getItem(STORAGE_KEY);
                if (!expiryTime) return false;
                
                const now = Date.now();
                const expiry = parseInt(expiryTime);
                const remaining = expiry - now;
                
                // Calcular quantos segundos faltam
                const remainingSeconds = Math.floor(remaining / 1000);
                const totalSeconds = Math.floor(PREVIEW_DURATION / 1000); // 600 segundos (10 min)
                
                // Tocar apenas nos primeiros AUDIO_DURATION segundos do cron√¥metro
                // Exemplo: se √°udio tem 10s, toca de 9:59 at√© 9:50 (590 a 600 segundos restantes)
                const minSeconds = totalSeconds - AUDIO_DURATION; // 590
                const maxSeconds = totalSeconds; // 600
                
                return remainingSeconds >= minSeconds && remainingSeconds <= maxSeconds;
            };
            
            // Tentar reproduzir o √°udio
            const playAudio = () => {
                if (!shouldPlayAudio()) {
                    console.log('√Åudio do cron√¥metro n√£o ser√° tocado (fora do intervalo inicial)');
                    return;
                }
                
                const audio = new Audio('../svg/√°udio-cronometro-banner.MP3');
                audio.volume = 0.5; // Volume em 50%
                
                audio.play().catch(err => {
                    console.log('Autoplay bloqueado pelo navegador:', err);
                    // Se autoplay for bloqueado, tentar reproduzir no primeiro clique do usu√°rio
                    document.addEventListener('click', () => {
                        if (shouldPlayAudio()) {
                            audio.play().catch(() => {});
                        }
                    }, { once: true });
                });
            };

            // Reproduzir quando a p√°gina carregar
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', playAudio);
            } else {
                playAudio();
            }
        })();

        // Controles de v√≠deo ao estilo Instagram - usando event delegation
        (function() {
            // V√≠deo atualmente reproduzindo (apenas 1 por vez)
            let currentPlayingVideo = null;
            
            // Vari√°veis para detectar scroll vs click
            let startX = 0;
            let startY = 0;
            let hasMoved = false;
            
            // Pausar todos os v√≠deos exceto o especificado
            function pauseAllVideosExcept(exceptVideo) {
                document.querySelectorAll('video').forEach(video => {
                    if (video !== exceptVideo && !video.paused) {
                        video.pause();
                        video.muted = true;
                        updateMuteIcon(video);
                    }
                });
            }
            
            // Atualizar √≠cone de mute de um v√≠deo
            function updateMuteIcon(video) {
                const container = video.closest('.post-image-container');
                if (!container) return;
                
                const muteBtn = container.querySelector('.video-mute-btn');
                if (!muteBtn) return;
                
                const soundIcon = muteBtn.querySelector('.sound-icon');
                const mutedIcon = muteBtn.querySelector('.muted-icon');
                
                if (video.muted || video.paused) {
                    if (soundIcon) soundIcon.style.display = 'none';
                    if (mutedIcon) mutedIcon.style.display = 'block';
                } else {
                    if (soundIcon) soundIcon.style.display = 'block';
                    if (mutedIcon) mutedIcon.style.display = 'none';
                }
            }
            
            // Toggle play/pause e mute de um v√≠deo
            function toggleVideo(video) {
                if (!video) return;
                
                if (video.paused) {
                    // Pausar todos os outros v√≠deos primeiro
                    pauseAllVideosExcept(video);
                    
                    // Reproduzir e desmutar este v√≠deo
                    video.muted = false;
                    video.play().catch(() => {
                        // Se falhar (autoplay bloqueado), tentar mutado
                        video.muted = true;
                        video.play().catch(() => {});
                    });
                    currentPlayingVideo = video;
                } else {
                    // Pausar e mutar
                    video.pause();
                    video.muted = true;
                    currentPlayingVideo = null;
                }
                
                updateMuteIcon(video);
            }
            
            // Detectar in√≠cio do toque/click
            function handleStart(e) {
                const video = e.target.closest('video') || e.target.closest('.post-image-container')?.querySelector('video');
                if (!video) return;
                
                // Ignorar se clicou no bot√£o de mute
                if (e.target.closest('.video-mute-btn')) return;
                
                hasMoved = false;
                
                if (e.type === 'touchstart') {
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                } else {
                    startX = e.clientX;
                    startY = e.clientY;
                }
            }
            
            // Detectar movimento (scroll)
            function handleMove(e) {
                if (hasMoved) return;
                
                let currentX, currentY;
                if (e.type === 'touchmove') {
                    currentX = e.touches[0].clientX;
                    currentY = e.touches[0].clientY;
                } else {
                    currentX = e.clientX;
                    currentY = e.clientY;
                }
                
                // Se moveu mais de 10px, √© scroll, n√£o click
                if (Math.abs(currentX - startX) > 10 || Math.abs(currentY - startY) > 10) {
                    hasMoved = true;
                }
            }
            
            // Detectar fim do toque/click
            function handleEnd(e) {
                // Se moveu (scroll), n√£o fazer nada
                if (hasMoved) {
                    hasMoved = false;
                    return;
                }
                
                // Ignorar se clicou no bot√£o de mute
                if (e.target.closest('.video-mute-btn')) return;
                
                const video = e.target.closest('video') || e.target.closest('.post-image-container')?.querySelector('video');
                if (video) {
                    toggleVideo(video);
                }
                
                hasMoved = false;
            }
            
            // Mouse events
            document.addEventListener('mousedown', handleStart, true);
            document.addEventListener('mousemove', handleMove, true);
            document.addEventListener('mouseup', handleEnd, true);
            
            // Touch events (para mobile)
            document.addEventListener('touchstart', handleStart, { passive: true, capture: true });
            document.addEventListener('touchmove', handleMove, { passive: true, capture: true });
            document.addEventListener('touchend', handleEnd, true);
            
            // Bloquear menu de contexto (op√ß√£o de baixar v√≠deo)
            document.addEventListener('contextmenu', function(e) {
                if (e.target.closest('video')) {
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
            }, true);
            
            // Event delegation para bot√£o de mute (mesma l√≥gica do click no v√≠deo)
            document.addEventListener('click', function(e) {
                const muteBtn = e.target.closest('.video-mute-btn');
                if (!muteBtn) return;
                
                e.preventDefault();
                e.stopPropagation();
                
                const container = muteBtn.closest('.post-image-container');
                if (!container) return;
                
                const video = container.querySelector('video');
                if (!video) return;
                
                toggleVideo(video);
            }, true);
            
            // Preload de v√≠deos quando entram na viewport (sem auto-play)
            function setupVideoPreload() {
                const videos = document.querySelectorAll('video');
                
                videos.forEach(video => {
                    // Verificar se j√° tem observer
                    if (video.dataset.observerAttached) return;
                    video.dataset.observerAttached = 'true';
                    
                    // For√ßar compress√£o visual via CSS
                    video.style.willChange = 'auto';
                    video.style.imageRendering = 'optimizeSpeed';
                    
                    // Garantir que come√ßa pausado e mutado
                    video.pause();
                    video.muted = true;
                    
                    const observer = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting && entry.intersectionRatio > 0.3) {
                                // S√≥ carregar metadata quando entrar na viewport (n√£o reproduzir)
                                if (video.preload === 'none') {
                                    video.preload = 'metadata';
                                    video.load();
                                }
                            } else if (!entry.isIntersecting) {
                                // Se sair da viewport, pausar e mutar
                                if (!video.paused) {
                                    video.pause();
                                    video.muted = true;
                                    updateMuteIcon(video);
                                }
                            }
                        });
                    }, { threshold: [0.3] });
                    
                    observer.observe(video);
                });
            }
            
            // Configurar preload periodicamente
            setInterval(setupVideoPreload, 1000);
            setupVideoPreload();
        })();
    </script>
</body>
</html>




